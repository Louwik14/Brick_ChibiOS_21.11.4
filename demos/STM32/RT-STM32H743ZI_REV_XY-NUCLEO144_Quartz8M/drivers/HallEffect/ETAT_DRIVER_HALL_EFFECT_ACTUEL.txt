ETAT DRIVER HALL EFFECT ACTUEL
==============================

Fichiers audités
----------------
- drivers/HallEffect/drv_hall.c
- drivers/HallEffect/drv_hall.h
- drivers/HallEffect/brick_asc.c
- drivers/HallEffect/brick_asc.h
- drivers/HallEffect/brick_cal.c
- drivers/HallEffect/brick_cal.h

Fonctions existantes (avant modification)
----------------------------------------
- drv_hall.c / drv_hall.h
  - hall_init(): initialise ADC, DMA, GPIO des multiplexeurs et démarre la conversion.
  - hall_update(): scanne les 8 positions des mux, remplit un tableau brut de 16 valeurs.
  - hall_get(i): renvoie la valeur brute d’un capteur.
  - Logique uniquement ADC/DMA + scan mux (pas de logique musicale).

- brick_asc.c / brick_asc.h
  - brick_asc_array_set_factors(): configure le lissage (moyenne mobile) par canal.
  - brick_asc_process(): applique le lissage et renvoie quand le buffer est plein.
  - Utilisation actuelle: aucune dans le driver Hall (potentiel futur pour filtrage).

- brick_cal.c / brick_cal.h
  - brick_cal_pot_*(): infrastructure de calibration (min/max/détent).
  - brick_cal_state global disponible pour un usage optionnel.
  - Utilisation actuelle: aucune dans le driver Hall.

Logique présente
---------------
- Acquisition ADC + DMA en mode continu.
- Sélection de multiplexeur via GPIOA[4..6].
- Lecture des deux ADC (MUXA/MUXB) pour obtenir 16 capteurs.
- Stockage des valeurs brutes dans hall_values[].
- Normalisation MIDI (0..127), états ON/OFF avec hystérésis, velocity/pressure.

Ce qui est utilisé / obsolète
-----------------------------
- Utilisé: l’ensemble ADC/DMA, mux_select(), hall_init(), hall_update(), hall_get().
- Obsolète dans l’état actuel: aucune suppression immédiate.
- Non utilisé actuellement mais conservé: brick_asc.*, brick_cal.* (prévu pour futur filtrage/calibration).

Ce qui peut être supprimé
-------------------------
- Rien pour l’instant. Les modules brick_asc/brick_cal restent utiles pour les étapes
  futures (filtrage et auto-calibration).

Ce qui est conservé
-------------------
- L’architecture ADC/DMA + scan mux.
- hall_init(), hall_update(), hall_get().
- Les modules brick_asc.* et brick_cal.* tels quels.

Ce qui est réécrit / modifié
----------------------------
- drv_hall.c / drv_hall.h: ajout d’une logique musicale générique 16 capteurs.
  - Détection NOTE ON/OFF avec hystérésis.
  - Calcul VELOCITY (vitesse d’évolution à l’attaque).
  - Calcul PRESSURE (valeur continue normalisée 0..127).
  - Calcul MIDI_VALUE (mapping brut temporaire).
  - Ajout d’API getters dédiés.

Analyse des causes réelles (constaté dans le code)
-------------------------------------------------
- Les constantes de calibration (HALL_RAW_REST/PRESSED, HALL_ON/OFF_THRESHOLD,
  HALL_VELOCITY_MAX_DELTA) sont exprimées à l’échelle **4k..6k** alors que les
  valeurs ADC observées en runtime sont ~36k..64k.
- Conséquences directes :
  - hall_map_to_midi() reçoit toujours une valeur **au-dessus du max** → MIDI = 127.
  - HALL_ON_THRESHOLD trop bas → gate bloqué sur ON, OFF jamais atteint.
  - HALL_VELOCITY_MAX_DELTA trop bas → velocity saturée à 127.

Ce qui était incorrect
----------------------
- Échelle des seuils et des min/max de mapping non cohérente avec les valeurs ADC
  réellement remontées (facteur x10).

Ce qui a été corrigé
-------------------
- Les constantes ont été remises à l’échelle du signal ADC (x10) :
  - HALL_RAW_REST ~36000
  - HALL_RAW_PRESSED ~64000
  - HALL_ON_THRESHOLD ~42000
  - HALL_OFF_THRESHOLD ~40000
  - HALL_VELOCITY_MAX_DELTA ~20000

Pourquoi
--------
- Rétablir une plage utile pour la normalisation MIDI (0..127).
- Réactiver l’hystérésis ON/OFF afin que l’état commute correctement.
- Éviter une velocity systématiquement saturée.

Ajouts récents (après modification)
----------------------------------
- Nouvelles APIs dans drv_hall.h:
  - hall_get_note_on(), hall_get_note_off(), hall_get_velocity(),
    hall_get_pressure(), hall_get_midi_value().
- Nouvelles structures internes dans drv_hall.c:
  - états note on/off, vélocité, pression, midi_value, gate par capteur.
  - seuils ON/OFF + mapping analogique -> MIDI.
- main.c:
  - debug ciblé sur B5 (index 4) avec affichage RAW/MIDI/ON-OFF/VEL/PRES.
  - envoi MIDI Note On/Off + Aftertouch par le main, sans dépendance Hall->MIDI.

Pourquoi (historique)
---------------------
- Respecter la contrainte: driver Hall autonome (pas de dépendance MIDI/USB).
- Centraliser la logique musicale dans le driver Hall pour les 16 capteurs.
- Fournir au main des états et valeurs normalisées pour l’envoi MIDI et le debug.
