ETAT DRIVER HALL EFFECT ACTUEL
==============================

Fichiers audités
----------------
- drivers/HallEffect/drv_hall.c
- drivers/HallEffect/drv_hall.h
- drivers/HallEffect/brick_asc.c
- drivers/HallEffect/brick_asc.h
- drivers/HallEffect/brick_cal.c
- drivers/HallEffect/brick_cal.h

Fonctions existantes (après modification)
----------------------------------------
- drv_hall.c / drv_hall.h
  - hall_init(): initialise ADC, DMA, GPIO des multiplexeurs, sélectionne le
    premier canal MUX et démarre la conversion continue.
  - hall_update(): ne scanne plus le MUX. Cette fonction ne fait que remettre à
    zéro les drapeaux NOTE ON/OFF consommés par l'application.
  - hall_get(i): renvoie la valeur brute d’un capteur.
  - Acquisition et logique musicale désormais pilotées par callback ADC (end_cb).

- brick_asc.c / brick_asc.h
  - brick_asc_array_set_factors(): configure le lissage (moyenne mobile) par canal.
  - brick_asc_process(): applique le lissage et renvoie quand le buffer est plein.
  - Utilisation actuelle: aucune dans le driver Hall (potentiel futur pour filtrage).

- brick_cal.c / brick_cal.h
  - brick_cal_pot_*(): infrastructure de calibration (min/max/détent).
  - brick_cal_state global disponible pour un usage optionnel.
  - Utilisation actuelle: aucune dans le driver Hall.

Architecture précédente (polling)
---------------------------------
- ADC + DMA en mode continu, buffer circulaire.
- hall_update() faisait le scan des 8 positions MUX:
  - mux_select(),
  - pause active (chThdSleepMicroseconds),
  - lecture du dernier sample DMA,
  - traitement des 16 capteurs.
- Cette boucle était dépendante de la charge CPU et de la cadence d'appel de
  hall_update(), donc non déterministe et sensible au jitter.

Nouvelle architecture (DMA + IRQ)
---------------------------------
- Le callback ADC end_cb est l'unique moteur d'échantillonnage.
- La conversion est en mode circulaire DMA, et end_cb est appelé par l'ISR DMA:
  - demi-buffer (HT) et buffer complet (TC) dans hal_adc_lld.c.
  - le macro adcIsBufferComplete() permet de savoir si le callback est déclenché
    sur demi-buffer ou buffer complet (hal_adc.h).
- Le driver utilise une profondeur DMA minimale (depth = 1):
  - un buffer de 2 samples (MUXA/MUXB),
  - un seul callback par groupe de conversion.
- Dans end_cb:
  - lecture du dernier échantillon DMA,
  - traitement des deux Hall (mux_ch et mux_ch+8),
  - incrément du MUX et sélection du canal suivant.
- Aucun chThdSleepMicroseconds(), pas de polling: la boucle est non bloquante.

Logique présente
---------------
- Acquisition ADC + DMA en mode continu.
- Sélection de multiplexeur via GPIOA[4..6].
- Lecture des deux ADC (MUXA/MUXB) pour obtenir 16 capteurs.
- Stockage des valeurs brutes dans hall_values[].
- Normalisation MIDI (0..127), états ON/OFF avec hystérésis, velocity/pressure.
- Traitement exécuté en ISR DMA via end_cb (IRQ-safe, sans attente active).

Ce qui est utilisé / obsolète
-----------------------------
- Utilisé: ADC/DMA, mux_select(), hall_init(), hall_update(), hall_get().
- Obsolète dans l’état actuel: aucune suppression immédiate.
- Non utilisé actuellement mais conservé: brick_asc.*, brick_cal.* (prévu pour futur filtrage/calibration).

Ce qui peut être supprimé
-------------------------
- Rien pour l’instant. Les modules brick_asc/brick_cal restent utiles pour les étapes
  futures (filtrage et auto-calibration).

Ce qui est conservé
-------------------
- L’architecture ADC/DMA (conversion continue) et la configuration analogique.
- mux_select() et le pinout MUX.
- hall_init(), hall_update(), hall_get().
- Les modules brick_asc.* et brick_cal.* tels quels.

Ce qui est réécrit / modifié
----------------------------
- drv_hall.c / drv_hall.h:
  - hall_update() ne scanne plus le MUX.
  - end_cb pilote la lecture DMA, le traitement Hall, et l'avance MUX.
  - profondeur DMA réduite à 1 (buffer minimal).
  - sélection du premier canal MUX avant démarrage ADC.

Analyse des causes réelles (constaté dans le code)
-------------------------------------------------
- Le scan MUX piloté par hall_update() dépendait du rythme du thread appelant,
  donc la latence et le jitter variaient avec la charge CPU.
- L'attente active (chThdSleepMicroseconds) ajoutait un délai fixe par position,
  amplifiant la latence cumulée.

Ce qui était incorrect
----------------------
- Boucle de scan MUX en polling, non déterministe et sensible au jitter.
- Latence cumulée artificielle liée à l'attente active.

Ce qui a été corrigé
-------------------
- Passage à une architecture IRQ-driven:
  - end_cb appelé par l'ISR DMA sur transfert complet (et demi-buffer si depth > 1).
  - lecture de l'échantillon dans le buffer DMA (index basé sur adcIsBufferComplete).
  - avance du MUX dans l'ISR, sans attente active.
- Latence réduite et plus stable (toute la chaîne est déclenchée par le DMA).

Pourquoi
--------
- Réduire la latence et le jitter (traitement immédiat à chaque conversion).
- Garantir une cadence déterministe, indépendante de la charge CPU.
- Rendre l'acquisition compatible avec d'autres DMA haute priorité (audio).

Paramètres réglables (nouveaux ou clarifiés)
--------------------------------------------
- HALL_VELOCITY_RATE_MIN / HALL_VELOCITY_RATE_MAX:
  bornes de normalisation de la vélocité (adapter au capteur).
- HALL_TRIGGER_RATE:
  seuil de pente minimale pour déclencher un NOTE ON.
- HALL_RETRIGGER_DELTA / HALL_HYSTERESIS:
  seuils de réarmement et OFF indépendants.

Clarification multi-capteurs (confusion B5)
-------------------------------------------
- Le driver Hall gère bien **16 capteurs** indépendants (boucle 0..15).
- La confusion « seule B5 fonctionne » venait du **main**, qui n’envoyait des
  messages MIDI que pour l’index 4 (B5) tout en affichant B5 en debug.
- Le correctif côté main envoie désormais les notes pour **tous les capteurs**,
  tout en gardant l’affichage debug focalisé sur B5.

Ajouts récents (après modification)
----------------------------------
- Nouvelles APIs dans drv_hall.h:
  - hall_get_note_on(), hall_get_note_off(), hall_get_velocity(),
    hall_get_pressure(), hall_get_midi_value().
- Nouvelles structures internes dans drv_hall.c:
  - états note on/off, vélocité, pression, midi_value, gate par capteur.
  - seuils ON/OFF + mapping analogique -> MIDI.
- main.c:
  - debug ciblé sur B5 (index 4) avec affichage RAW/MIDI/ON-OFF/VEL/PRES.
  - envoi MIDI Note On/Off + Aftertouch par le main, sans dépendance Hall->MIDI.

Pourquoi (historique)
---------------------
- Respecter la contrainte: driver Hall autonome (pas de dépendance MIDI/USB).
- Centraliser la logique musicale dans le driver Hall pour les 16 capteurs.
- Fournir au main des états et valeurs normalisées pour l’envoi MIDI et le debug.
