ETAT DRIVER HALL EFFECT ACTUEL
==============================

Fichiers audités
----------------
- drivers/HallEffect/drv_hall.c
- drivers/HallEffect/drv_hall.h
- drivers/HallEffect/brick_asc.c
- drivers/HallEffect/brick_asc.h
- drivers/HallEffect/brick_cal.c
- drivers/HallEffect/brick_cal.h

Fonctions existantes (après modification)
----------------------------------------
- drv_hall.c / drv_hall.h
  - hall_init(): initialise ADC, DMA, GPIO des multiplexeurs, sélectionne le
    premier canal MUX, démarre le timer matériel (20 kHz) et la conversion ADC
    déclenchée par trigger externe.
  - hall_update(): ne scanne plus le MUX. Cette fonction ne fait que remettre à
    zéro les drapeaux NOTE ON/OFF consommés par l'application.
  - hall_get(i): renvoie la valeur brute d’un capteur.
  - Acquisition et logique musicale désormais pilotées par callback ADC (end_cb).

- brick_asc.c / brick_asc.h
  - brick_asc_array_set_factors(): configure le lissage (moyenne mobile) par canal.
  - brick_asc_process(): applique le lissage et renvoie quand le buffer est plein.
  - Utilisation actuelle: aucune dans le driver Hall (potentiel futur pour filtrage).

- brick_cal.c / brick_cal.h
  - brick_cal_pot_*(): infrastructure de calibration (min/max/détent).
  - brick_cal_state global disponible pour un usage optionnel.
  - Utilisation actuelle: aucune dans le driver Hall.

Architecture précédente (polling)
---------------------------------
- ADC + DMA en mode continu, buffer circulaire.
- hall_update() faisait le scan des 8 positions MUX:
  - mux_select(),
  - pause active (chThdSleepMicroseconds),
  - lecture du dernier sample DMA,
  - traitement des 16 capteurs.
- Cette boucle était dépendante de la charge CPU et de la cadence d'appel de
  hall_update(), donc non déterministe et sensible au jitter.

Nouvelle architecture (Timer → ADC → DMA → IRQ)
-----------------------------------------------
- Un timer matériel déclenche l'ADC à 20 kHz:
  - configuration GPT via hal_gpt_lld.h (GPTConfig.frequency/CR2).
  - TRGO sur update event (TIM_CR2_MMS_1) conformément à l'exemple
    STM32H743 dans testhal/STM32/multi/ADC/cfg/stm32h743zi_nucleo144/portab.c.
- L'ADC est déclenché en externe via CFGR:
  - ADC_CFGR_EXTEN_RISING + ADC_CFGR_EXTSEL_SRC(12) (TIM4_TRGO).
  - Toujours en DMA circulaire (pipeline ADC + DMA intact).
- Le callback ADC end_cb est l'unique moteur d'échantillonnage:
  - LLD ADC: « If circular buffer depth > 1, then the half transfer interrupt
    is enabled in order to allow streaming processing. » (hal_adc_lld.c)
  - depth = 1 → un seul callback par conversion.
- Dans end_cb:
  - lecture du buffer DMA (2 samples MUXA/MUXB),
  - traitement des deux Hall (mux_ch et mux_ch+8),
  - avance du MUX et sélection du canal suivant.
- Aucun chThdSleepMicroseconds(), pas de polling: la boucle est non bloquante
  et déterministe.

Mécanismes ChibiOS utilisés (références)
----------------------------------------
- ADCConversionGroup (hal_adc.h): structure "Conversion group configuration"
  + callback end_cb pour le traitement en IRQ.
- ADC LLD (hal_adc_lld.c/.h, ADCv4): configuration CFGR + DMA circulaire,
  end_cb déclenché par l'ISR DMA sur transfert complet.
- GPT LLD (hal_gpt_lld.h/.c, TIMv1): timer matériel et champ CR2 (TRGO).
- ST driver (hal_st.h): API de timer système (stGetCounter/stStartAlarm),
  non utilisée pour l'acquisition; l'horloge d'échantillonnage est fournie
  par GPT.

Logique présente
---------------
- Acquisition ADC + DMA avec trigger externe (timer 20 kHz).
- Sélection de multiplexeur via GPIOA[4..6].
- Lecture des deux ADC (MUXA/MUXB) pour obtenir 16 capteurs.
- Stockage des valeurs brutes dans hall_values[].
- Normalisation MIDI (0..127), états ON/OFF avec hystérésis, velocity/pressure.
- Traitement exécuté en ISR DMA via end_cb (IRQ-safe, sans attente active).

Ce qui est utilisé / obsolète
-----------------------------
- Utilisé: ADC/DMA, mux_select(), hall_init(), hall_update(), hall_get().
- Obsolète dans l’état actuel: aucune suppression immédiate.
- Non utilisé actuellement mais conservé: brick_asc.*, brick_cal.* (prévu pour futur filtrage/calibration).

Ce qui peut être supprimé
-------------------------
- Rien pour l’instant. Les modules brick_asc/brick_cal restent utiles pour les étapes
  futures (filtrage et auto-calibration).

Ce qui est conservé
-------------------
- L’architecture ADC/DMA et la configuration analogique (canaux, SMPR, PCSEL).
- mux_select() et le pinout MUX.
- hall_init(), hall_update(), hall_get().
- Les modules brick_asc.* et brick_cal.* tels quels.

Ce qui est réécrit / modifié
----------------------------
- drv_hall.c / drv_hall.h:
  - hall_update() ne scanne plus le MUX.
  - end_cb pilote la lecture DMA, le traitement Hall, et l'avance MUX.
  - profondeur DMA réduite à 1 (buffer minimal).
  - sélection du premier canal MUX avant démarrage ADC.

Analyse des causes réelles (constaté dans le code)
-------------------------------------------------
- Le scan MUX piloté par hall_update() dépendait du rythme du thread appelant,
  donc la latence et le jitter variaient avec la charge CPU.
- L'attente active (chThdSleepMicroseconds) ajoutait un délai fixe par position,
  amplifiant la latence cumulée.

Ce qui était incorrect
----------------------
- Boucle de scan MUX en polling, non déterministe et sensible au jitter.
- Latence cumulée artificielle liée à l'attente active.

Ce qui a été corrigé
-------------------
- Passage à une architecture timer-driven et IRQ-driven:
  - Timer (20 kHz) → ADC (trigger externe) → DMA → IRQ → Hall processing → MUX.
  - end_cb appelé à chaque conversion DMA (depth = 1).
  - avance du MUX dans l'ISR, sans attente active.
- Latence réduite et plus stable (toute la chaîne est déclenchée par le timer).
- Correction de la logique NOTE ON/OFF:
  - Avant: conditions basées uniquement sur la valeur instantanée (pas de
    détection de franchissement), donc si le signal ne repassait pas sous
    retrigger_threshold entre deux scans, hall_armed restait à false et
    NOTE ON n'était jamais autorisé.
  - Après: détection de franchissement (prev -> current) pour ON/OFF et
    réarmement uniquement sur passage sous retrigger_threshold.
  - Des variables de debug (adjusted / thresholds / rate / armed / gate)
    sont stockées pour inspection au debugger et valider les seuils.

Pourquoi
--------
- Réduire la latence et le jitter (traitement immédiat à chaque conversion).
- Garantir une cadence déterministe (20 kHz fixe), indépendante de la charge CPU.
- Assurer une charge CPU bornée et compatible avec les DMA haute priorité (audio).
- Rendre les événements NOTE ON/OFF fiables même en cas de variations rapides
  autour des seuils (détection de franchissement).

Paramètres réglables (nouveaux ou clarifiés)
--------------------------------------------
- HALL_VELOCITY_RATE_MIN / HALL_VELOCITY_RATE_MAX:
  bornes de normalisation de la vélocité (adapter au capteur).
- HALL_TRIGGER_RATE:
  seuil de pente minimale pour déclencher un NOTE ON.
- HALL_RETRIGGER_DELTA / HALL_HYSTERESIS:
  seuils de réarmement et OFF indépendants.

Clarification multi-capteurs (confusion B5)
-------------------------------------------
- Le driver Hall gère bien **16 capteurs** indépendants (boucle 0..15).
- La confusion « seule B5 fonctionne » venait du **main**, qui n’envoyait des
  messages MIDI que pour l’index 4 (B5) tout en affichant B5 en debug.
- Le correctif côté main envoie désormais les notes pour **tous les capteurs**,
  tout en gardant l’affichage debug focalisé sur B5.

Ajouts récents (après modification)
----------------------------------
- Nouvelles APIs dans drv_hall.h:
  - hall_get_note_on(), hall_get_note_off(), hall_get_velocity(),
    hall_get_pressure(), hall_get_midi_value().
- Nouvelles structures internes dans drv_hall.c:
  - états note on/off, vélocité, pression, midi_value, gate par capteur.
  - seuils ON/OFF + mapping analogique -> MIDI.
- main.c:
  - debug ciblé sur B5 (index 4) avec affichage RAW/MIDI/ON-OFF/VEL/PRES.
  - envoi MIDI Note On/Off + Aftertouch par le main, sans dépendance Hall->MIDI.

Pourquoi (historique)
---------------------
- Respecter la contrainte: driver Hall autonome (pas de dépendance MIDI/USB).
- Centraliser la logique musicale dans le driver Hall pour les 16 capteurs.
- Fournir au main des états et valeurs normalisées pour l’envoi MIDI et le debug.
