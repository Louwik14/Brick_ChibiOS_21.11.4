ETAT DRIVER HALL EFFECT ACTUEL
==============================

Fichiers audités
----------------
- drivers/HallEffect/drv_hall.c
- drivers/HallEffect/drv_hall.h
- drivers/HallEffect/brick_asc.c
- drivers/HallEffect/brick_asc.h
- drivers/HallEffect/brick_cal.c
- drivers/HallEffect/brick_cal.h

Fonctions existantes (avant modification)
----------------------------------------
- drv_hall.c / drv_hall.h
  - hall_init(): initialise ADC, DMA, GPIO des multiplexeurs et démarre la conversion.
  - hall_update(): scanne les 8 positions des mux, remplit un tableau brut de 16 valeurs.
  - hall_get(i): renvoie la valeur brute d’un capteur.
  - Logique uniquement ADC/DMA + scan mux (pas de logique musicale).

- brick_asc.c / brick_asc.h
  - brick_asc_array_set_factors(): configure le lissage (moyenne mobile) par canal.
  - brick_asc_process(): applique le lissage et renvoie quand le buffer est plein.
  - Utilisation actuelle: aucune dans le driver Hall (potentiel futur pour filtrage).

- brick_cal.c / brick_cal.h
  - brick_cal_pot_*(): infrastructure de calibration (min/max/détent).
  - brick_cal_state global disponible pour un usage optionnel.
  - Utilisation actuelle: aucune dans le driver Hall.

Logique présente
---------------
- Acquisition ADC + DMA en mode continu.
- Sélection de multiplexeur via GPIOA[4..6].
- Lecture des deux ADC (MUXA/MUXB) pour obtenir 16 capteurs.
- Stockage des valeurs brutes dans hall_values[].
- Normalisation MIDI (0..127), états ON/OFF avec hystérésis, velocity/pressure.

Ce qui est utilisé / obsolète
-----------------------------
- Utilisé: l’ensemble ADC/DMA, mux_select(), hall_init(), hall_update(), hall_get().
- Obsolète dans l’état actuel: aucune suppression immédiate.
- Non utilisé actuellement mais conservé: brick_asc.*, brick_cal.* (prévu pour futur filtrage/calibration).

Ce qui peut être supprimé
-------------------------
- Rien pour l’instant. Les modules brick_asc/brick_cal restent utiles pour les étapes
  futures (filtrage et auto-calibration).

Ce qui est conservé
-------------------
- L’architecture ADC/DMA + scan mux.
- hall_init(), hall_update(), hall_get().
- Les modules brick_asc.* et brick_cal.* tels quels.

Ce qui est réécrit / modifié
----------------------------
- drv_hall.c / drv_hall.h: logique musicale réécrite.
  - Détection NOTE ON/OFF avec hystérésis et réarmement explicite.
  - Calcul VELOCITY basé sur la dérivée temporelle (Δvaleur / Δtemps).
  - Calcul PRESSURE (valeur continue normalisée 0..127).
  - Calcul MIDI_VALUE (mapping brut temporaire).
  - Ajout d’états par capteur (temps précédent, valeur précédente, armement).

Analyse des causes réelles (constaté dans le code)
-------------------------------------------------
- La velocity était calculée sur une simple différence de deux samples consécutifs.
  Cette approche dépendait directement du polling rate et du timing du scan mux,
  rendant la vélocité instable et la latence perceptible.
- La logique NOTE ON/OFF reposait uniquement sur un gate binaire; sans mécanisme
  de réarmement explicite, un relâchement partiel pouvait empêcher un retrigger
  (la valeur ne repassait pas sous le seuil OFF).

Ce qui était incorrect
----------------------
- Calcul de velocity basé sur Δvaleur sans Δtemps (dépendant du polling).
- Réarmement implicite uniquement via franchissement du seuil OFF → retriggers ratés.

Ce qui a été corrigé
-------------------
- Ajout d’un état par capteur:
  - valeur précédente + timestamp précédent.
  - drapeau d’armement pour autoriser un retrigger.
- Calcul de velocity basé sur la dérivée temporelle (Δvaleur / Δtemps).
- Seuils distincts pour:
  - NOTE ON (franchissement vers le haut),
  - OFF (hystérésis),
  - réarmement (retrigger sans retour complet au repos).

Pourquoi
--------
- Stabiliser la vélocité (indépendante du polling).
- Supprimer la latence perçue à l’attaque.
- Autoriser les retriggers même sans retour complet à zéro.

Clarification multi-capteurs (confusion B5)
-------------------------------------------
- Le driver Hall gère bien **16 capteurs** indépendants (boucle 0..15 dans
  hall_update + états par canal).
- La confusion « seule B5 fonctionne » venait du **main**, qui n’envoyait des
  messages MIDI que pour l’index 4 (B5) tout en affichant B5 en debug.
- Le correctif côté main envoie désormais les notes pour **tous les capteurs**,
  tout en gardant l’affichage debug focalisé sur B5.

Ajouts récents (après modification)
----------------------------------
- Nouvelles APIs dans drv_hall.h:
  - hall_get_note_on(), hall_get_note_off(), hall_get_velocity(),
    hall_get_pressure(), hall_get_midi_value().
- Nouvelles structures internes dans drv_hall.c:
  - états note on/off, vélocité, pression, midi_value, gate par capteur.
  - seuils ON/OFF + mapping analogique -> MIDI.
- main.c:
  - debug ciblé sur B5 (index 4) avec affichage RAW/MIDI/ON-OFF/VEL/PRES.
  - envoi MIDI Note On/Off + Aftertouch par le main, sans dépendance Hall->MIDI.

Pourquoi (historique)
---------------------
- Respecter la contrainte: driver Hall autonome (pas de dépendance MIDI/USB).
- Centraliser la logique musicale dans le driver Hall pour les 16 capteurs.
- Fournir au main des états et valeurs normalisées pour l’envoi MIDI et le debug.
