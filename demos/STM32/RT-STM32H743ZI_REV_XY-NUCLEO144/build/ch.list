
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080003b9 	.word	0x080003b9
 8000008:	080003bb 	.word	0x080003bb
 800000c:	080003bb 	.word	0x080003bb
 8000010:	080003bb 	.word	0x080003bb
 8000014:	080003bb 	.word	0x080003bb
 8000018:	080003bb 	.word	0x080003bb
 800001c:	080003bb 	.word	0x080003bb
 8000020:	080003bb 	.word	0x080003bb
 8000024:	080003bb 	.word	0x080003bb
 8000028:	080003bb 	.word	0x080003bb
 800002c:	08002ac1 	.word	0x08002ac1
 8000030:	080003bb 	.word	0x080003bb
 8000034:	080003bb 	.word	0x080003bb
 8000038:	080003bb 	.word	0x080003bb
 800003c:	080003bb 	.word	0x080003bb
 8000040:	080003bb 	.word	0x080003bb
 8000044:	080003bb 	.word	0x080003bb
 8000048:	080003bb 	.word	0x080003bb
 800004c:	080003bb 	.word	0x080003bb
 8000050:	080003bb 	.word	0x080003bb
 8000054:	080003bb 	.word	0x080003bb
 8000058:	080003bb 	.word	0x080003bb
 800005c:	080003bb 	.word	0x080003bb
 8000060:	080003bb 	.word	0x080003bb
 8000064:	080003bb 	.word	0x080003bb
 8000068:	080003bb 	.word	0x080003bb
 800006c:	08001151 	.word	0x08001151
 8000070:	08001191 	.word	0x08001191
 8000074:	080011d1 	.word	0x080011d1
 8000078:	08001211 	.word	0x08001211
 800007c:	08001251 	.word	0x08001251
 8000080:	08001291 	.word	0x08001291
 8000084:	080012d1 	.word	0x080012d1
 8000088:	08000ea1 	.word	0x08000ea1
 800008c:	080003bb 	.word	0x080003bb
 8000090:	080003bb 	.word	0x080003bb
 8000094:	080003bb 	.word	0x080003bb
 8000098:	080003bb 	.word	0x080003bb
 800009c:	080003bb 	.word	0x080003bb
 80000a0:	080003bb 	.word	0x080003bb
 80000a4:	080003bb 	.word	0x080003bb
 80000a8:	080003bb 	.word	0x080003bb
 80000ac:	080003bb 	.word	0x080003bb
 80000b0:	08000c61 	.word	0x08000c61
 80000b4:	080003bb 	.word	0x080003bb
 80000b8:	080003bb 	.word	0x080003bb
 80000bc:	080003bb 	.word	0x080003bb
 80000c0:	080003bb 	.word	0x080003bb
 80000c4:	080003bb 	.word	0x080003bb
 80000c8:	080003bb 	.word	0x080003bb
 80000cc:	080020a1 	.word	0x080020a1
 80000d0:	08002111 	.word	0x08002111
 80000d4:	08000c01 	.word	0x08000c01
 80000d8:	080003bb 	.word	0x080003bb
 80000dc:	080003bb 	.word	0x080003bb
 80000e0:	080003bb 	.word	0x080003bb
 80000e4:	080003bb 	.word	0x080003bb
 80000e8:	080003bb 	.word	0x080003bb
 80000ec:	080003bb 	.word	0x080003bb
 80000f0:	080003bb 	.word	0x080003bb
 80000f4:	080003bb 	.word	0x080003bb
 80000f8:	080003bb 	.word	0x080003bb
 80000fc:	08001311 	.word	0x08001311
 8000100:	080003bb 	.word	0x080003bb
 8000104:	08000bd1 	.word	0x08000bd1
 8000108:	080003bb 	.word	0x080003bb
 800010c:	08002181 	.word	0x08002181
 8000110:	080003bb 	.word	0x080003bb
 8000114:	08000c31 	.word	0x08000c31
 8000118:	080003bb 	.word	0x080003bb
 800011c:	080003bb 	.word	0x080003bb
 8000120:	08001351 	.word	0x08001351
 8000124:	08001391 	.word	0x08001391
 8000128:	080013d1 	.word	0x080013d1
 800012c:	08001411 	.word	0x08001411
 8000130:	08001451 	.word	0x08001451
 8000134:	080003bb 	.word	0x080003bb
 8000138:	080003bb 	.word	0x080003bb
 800013c:	080003bb 	.word	0x080003bb
 8000140:	080003bb 	.word	0x080003bb
 8000144:	080003bb 	.word	0x080003bb
 8000148:	080003bb 	.word	0x080003bb
 800014c:	080003bb 	.word	0x080003bb
 8000150:	08001491 	.word	0x08001491
 8000154:	080014d1 	.word	0x080014d1
 8000158:	08001511 	.word	0x08001511
 800015c:	080003bb 	.word	0x080003bb
 8000160:	080003bb 	.word	0x080003bb
 8000164:	080003bb 	.word	0x080003bb
 8000168:	080003bb 	.word	0x080003bb
 800016c:	080003bb 	.word	0x080003bb
 8000170:	080003bb 	.word	0x080003bb
 8000174:	080003bb 	.word	0x080003bb
 8000178:	080003bb 	.word	0x080003bb
 800017c:	080003bb 	.word	0x080003bb
 8000180:	080003bb 	.word	0x080003bb
 8000184:	080003bb 	.word	0x080003bb
 8000188:	080003bb 	.word	0x080003bb
 800018c:	080003bb 	.word	0x080003bb
 8000190:	080003bb 	.word	0x080003bb
 8000194:	080021f1 	.word	0x080021f1
 8000198:	08002261 	.word	0x08002261
 800019c:	080003bb 	.word	0x080003bb
 80001a0:	080003bb 	.word	0x080003bb
 80001a4:	080003bb 	.word	0x080003bb
 80001a8:	080003bb 	.word	0x080003bb
 80001ac:	080003bb 	.word	0x080003bb
 80001b0:	080003bb 	.word	0x080003bb
 80001b4:	080003bb 	.word	0x080003bb
 80001b8:	080003bb 	.word	0x080003bb
 80001bc:	080003bb 	.word	0x080003bb
 80001c0:	080003bb 	.word	0x080003bb
 80001c4:	080003bb 	.word	0x080003bb
 80001c8:	080003bb 	.word	0x080003bb
 80001cc:	080003bb 	.word	0x080003bb
 80001d0:	080003bb 	.word	0x080003bb
 80001d4:	08001a51 	.word	0x08001a51
 80001d8:	080003bb 	.word	0x080003bb
 80001dc:	080003bb 	.word	0x080003bb
 80001e0:	080003bb 	.word	0x080003bb
 80001e4:	080003bb 	.word	0x080003bb
 80001e8:	080003bb 	.word	0x080003bb
 80001ec:	080003bb 	.word	0x080003bb
 80001f0:	080003bb 	.word	0x080003bb
 80001f4:	080003bb 	.word	0x080003bb
 80001f8:	080003bb 	.word	0x080003bb
 80001fc:	080003bb 	.word	0x080003bb
 8000200:	080003bb 	.word	0x080003bb
 8000204:	080003bb 	.word	0x080003bb
 8000208:	080003bb 	.word	0x080003bb
 800020c:	080003bb 	.word	0x080003bb
 8000210:	080003bb 	.word	0x080003bb
 8000214:	080003bb 	.word	0x080003bb
 8000218:	080003bb 	.word	0x080003bb
 800021c:	080003bb 	.word	0x080003bb
 8000220:	080003bb 	.word	0x080003bb
 8000224:	080003bb 	.word	0x080003bb
 8000228:	080003bb 	.word	0x080003bb
 800022c:	080003bb 	.word	0x080003bb
 8000230:	080003bb 	.word	0x080003bb
 8000234:	080003bb 	.word	0x080003bb
 8000238:	080003bb 	.word	0x080003bb
 800023c:	080003bb 	.word	0x080003bb
 8000240:	080003bb 	.word	0x080003bb
 8000244:	08000f51 	.word	0x08000f51
 8000248:	08000f91 	.word	0x08000f91
 800024c:	08000fd1 	.word	0x08000fd1
 8000250:	08001011 	.word	0x08001011
 8000254:	08001051 	.word	0x08001051
 8000258:	08001091 	.word	0x08001091
 800025c:	080010d1 	.word	0x080010d1
 8000260:	08001111 	.word	0x08001111
 8000264:	080003bb 	.word	0x080003bb
 8000268:	080003bb 	.word	0x080003bb
 800026c:	080003bb 	.word	0x080003bb
 8000270:	080003bb 	.word	0x080003bb
 8000274:	080003bb 	.word	0x080003bb
 8000278:	080003bb 	.word	0x080003bb
 800027c:	080003bb 	.word	0x080003bb
 8000280:	080003bb 	.word	0x080003bb
 8000284:	080003bb 	.word	0x080003bb
 8000288:	080003bb 	.word	0x080003bb
 800028c:	080003bb 	.word	0x080003bb
 8000290:	080003bb 	.word	0x080003bb
 8000294:	080003bb 	.word	0x080003bb
 8000298:	080003bb 	.word	0x080003bb
 800029c:	080003bb 	.word	0x080003bb
 80002a0:	080003bb 	.word	0x080003bb
 80002a4:	080003bb 	.word	0x080003bb
 80002a8:	080003bb 	.word	0x080003bb
 80002ac:	080003bb 	.word	0x080003bb
 80002b0:	080003bb 	.word	0x080003bb
 80002b4:	080003bb 	.word	0x080003bb
 80002b8:	080003bb 	.word	0x080003bb
 80002bc:	080003bb 	.word	0x080003bb
 80002c0:	080003bb 	.word	0x080003bb
 80002c4:	080003bb 	.word	0x080003bb
 80002c8:	080003bb 	.word	0x080003bb
 80002cc:	080003bb 	.word	0x080003bb
 80002d0:	080003bb 	.word	0x080003bb
 80002d4:	080003bb 	.word	0x080003bb
 80002d8:	080003bb 	.word	0x080003bb
 80002dc:	080003bb 	.word	0x080003bb

Disassembly of section .text:

080002e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80002e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80002e2:	4826      	ldr	r0, [pc, #152]	; (800037c <_crt0_entry+0x9c>)
                msr     MSP, r0
 80002e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80002e8:	4825      	ldr	r0, [pc, #148]	; (8000380 <_crt0_entry+0xa0>)
                msr     PSP, r0
 80002ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80002ee:	4825      	ldr	r0, [pc, #148]	; (8000384 <_crt0_entry+0xa4>)
                ldr     r1, =SCB_VTOR
 80002f0:	4925      	ldr	r1, [pc, #148]	; (8000388 <_crt0_entry+0xa8>)
                str     r0, [r1]
 80002f2:	6008      	str	r0, [r1, #0]
                movt    r1, #SCB_FPDSCR >> 16
                str     r0, [r1]
#endif

                /* CONTROL register initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 80002f4:	2002      	movs	r0, #2
                msr     CONTROL, r0
 80002f6:	f380 8814 	msr	CONTROL, r0
                isb
 80002fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80002fe:	f000 f877 	bl	80003f0 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000302:	f002 f885 	bl	8002410 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000306:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800030a:	4920      	ldr	r1, [pc, #128]	; (800038c <_crt0_entry+0xac>)
                ldr     r2, =__main_stack_end__
 800030c:	4a1b      	ldr	r2, [pc, #108]	; (800037c <_crt0_entry+0x9c>)
.Lmsloop:
                cmp     r1, r2
 800030e:	4291      	cmp	r1, r2
                itt     lo
 8000310:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000312:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lmsloop
 8000316:	e7fa      	bcc.n	800030e <_crt0_entry+0x2e>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000318:	491d      	ldr	r1, [pc, #116]	; (8000390 <_crt0_entry+0xb0>)
                ldr     r2, =__process_stack_end__
 800031a:	4a19      	ldr	r2, [pc, #100]	; (8000380 <_crt0_entry+0xa0>)
.Lpsloop:
                cmp     r1, r2
 800031c:	4291      	cmp	r1, r2
                itt     lo
 800031e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000320:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lpsloop
 8000324:	e7fa      	bcc.n	800031c <_crt0_entry+0x3c>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000326:	491b      	ldr	r1, [pc, #108]	; (8000394 <_crt0_entry+0xb4>)
                ldr     r2, =__data_base__
 8000328:	4a1b      	ldr	r2, [pc, #108]	; (8000398 <_crt0_entry+0xb8>)
                ldr     r3, =__data_end__
 800032a:	4b1c      	ldr	r3, [pc, #112]	; (800039c <_crt0_entry+0xbc>)
.Ldloop:
                cmp     r2, r3
 800032c:	429a      	cmp	r2, r3
                ittt    lo
 800032e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000330:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000334:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     .Ldloop
 8000338:	e7f8      	bcc.n	800032c <_crt0_entry+0x4c>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800033a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800033c:	4918      	ldr	r1, [pc, #96]	; (80003a0 <_crt0_entry+0xc0>)
                ldr     r2, =__bss_end__
 800033e:	4a19      	ldr	r2, [pc, #100]	; (80003a4 <_crt0_entry+0xc4>)
.Lbloop:
                cmp     r1, r2
 8000340:	4291      	cmp	r1, r2
                itt     lo
 8000342:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000344:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     .Lbloop
 8000348:	e7fa      	bcc.n	8000340 <_crt0_entry+0x60>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800034a:	f000 f8a1 	bl	8000490 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800034e:	f000 f88f 	bl	8000470 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000352:	4c15      	ldr	r4, [pc, #84]	; (80003a8 <_crt0_entry+0xc8>)
                ldr     r5, =__init_array_end__
 8000354:	4d15      	ldr	r5, [pc, #84]	; (80003ac <_crt0_entry+0xcc>)
.Linitloop:
                cmp     r4, r5
 8000356:	42ac      	cmp	r4, r5
                bge     .Lendinitloop
 8000358:	da03      	bge.n	8000362 <_crt0_entry+0x82>
                ldr     r1, [r4], #4
 800035a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800035e:	4788      	blx	r1
                b       .Linitloop
 8000360:	e7f9      	b.n	8000356 <_crt0_entry+0x76>
.Lendinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000362:	f002 fbe5 	bl	8002b30 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000366:	4c12      	ldr	r4, [pc, #72]	; (80003b0 <_crt0_entry+0xd0>)
                ldr     r5, =__fini_array_end__
 8000368:	4d12      	ldr	r5, [pc, #72]	; (80003b4 <_crt0_entry+0xd4>)
.Lfiniloop:
                cmp     r4, r5
 800036a:	42ac      	cmp	r4, r5
                bge     .Lendfiniloop
 800036c:	da03      	bge.n	8000376 <_crt0_entry+0x96>
                ldr     r1, [r4], #4
 800036e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000372:	4788      	blx	r1
                b       .Lfiniloop
 8000374:	e7f9      	b.n	800036a <_crt0_entry+0x8a>
.Lendfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000376:	f000 b883 	b.w	8000480 <__default_exit>
 800037a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800037c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000380:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000384:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000388:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800038c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000390:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000394:	08002e2c 	.word	0x08002e2c
                ldr     r2, =__data_base__
 8000398:	24000000 	.word	0x24000000
                ldr     r3, =__data_end__
 800039c:	24000000 	.word	0x24000000
                ldr     r1, =__bss_base__
 80003a0:	24000000 	.word	0x24000000
                ldr     r2, =__bss_end__
 80003a4:	24000c80 	.word	0x24000c80
                ldr     r4, =__init_array_base__
 80003a8:	080002e0 	.word	0x080002e0
                ldr     r5, =__init_array_end__
 80003ac:	080002e0 	.word	0x080002e0
                ldr     r4, =__fini_array_base__
 80003b0:	080002e0 	.word	0x080002e0
                ldr     r5, =__fini_array_end__
 80003b4:	080002e0 	.word	0x080002e0

080003b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80003b8:	e792      	b.n	80002e0 <_crt0_entry>

080003ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80003ba:	f000 f800 	bl	80003be <_unhandled_exception>

080003be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80003be:	e7fe      	b.n	80003be <_unhandled_exception>

080003c0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80003c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80003c4:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
 80003c8:	f8d0 d00c 	ldr.w	sp, [r0, #12]

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80003cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080003d0 <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80003d0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80003d2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80003d6:	4628      	mov	r0, r5
                blx     r4
 80003d8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80003da:	2000      	movs	r0, #0
                bl      chThdExit
 80003dc:	f002 faf0 	bl	80029c0 <chThdExit>

080003e0 <.zombies>:
.zombies:       b       .zombies
 80003e0:	e7fe      	b.n	80003e0 <.zombies>

080003e2 <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
 80003e2:	f002 fabd 	bl	8002960 <chSchDoPreemption>

080003e6 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80003e6:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80003e8:	e7fe      	b.n	80003e8 <__port_exit_from_isr+0x2>
 80003ea:	0000      	movs	r0, r0
 80003ec:	0000      	movs	r0, r0
	...

080003f0 <__cpu_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __cpu_init(void) {
 80003f0:	b510      	push	{r4, lr}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80003f2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80003f6:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80003fa:	481c      	ldr	r0, [pc, #112]	; (800046c <__cpu_init+0x7c>)
 80003fc:	2200      	movs	r2, #0
 80003fe:	f8c0 2250 	str.w	r2, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000402:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000406:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 800040a:	6943      	ldr	r3, [r0, #20]
 800040c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000410:	6143      	str	r3, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000412:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000416:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 800041a:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 800041e:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000422:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000426:	f643 74e0 	movw	r4, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 800042a:	f3c3 3c4e 	ubfx	ip, r3, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 800042e:	f3c3 0ec9 	ubfx	lr, r3, #3, #10
 8000432:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000436:	ea0c 0104 	and.w	r1, ip, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 800043a:	4673      	mov	r3, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800043c:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8000440:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000442:	f8c0 2260 	str.w	r2, [r0, #608]	; 0x260
      } while (ways-- != 0U);
 8000446:	1c5a      	adds	r2, r3, #1
 8000448:	d1f8      	bne.n	800043c <__cpu_init+0x4c>
    } while(sets-- != 0U);
 800044a:	f1ac 0c20 	sub.w	ip, ip, #32
 800044e:	f11c 0f20 	cmn.w	ip, #32
 8000452:	d1f0      	bne.n	8000436 <__cpu_init+0x46>
 8000454:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8000458:	6943      	ldr	r3, [r0, #20]
 800045a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800045e:	6143      	str	r3, [r0, #20]
 8000460:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000464:	f3bf 8f6f 	isb	sy

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000468:	bd10      	pop	{r4, pc}
 800046a:	bf00      	nop
 800046c:	e000ed00 	.word	0xe000ed00

08000470 <__late_init>:
 8000470:	4770      	bx	lr
 8000472:	bf00      	nop
	...

08000480 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8000480:	e7fe      	b.n	8000480 <__default_exit>
 8000482:	bf00      	nop
	...

08000490 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000490:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000492:	4d2b      	ldr	r5, [pc, #172]	; (8000540 <__init_ram_areas+0xb0>)
 8000494:	4f2b      	ldr	r7, [pc, #172]	; (8000544 <__init_ram_areas+0xb4>)
 8000496:	492c      	ldr	r1, [pc, #176]	; (8000548 <__init_ram_areas+0xb8>)
 8000498:	f105 0470 	add.w	r4, r5, #112	; 0x70
 800049c:	482b      	ldr	r0, [pc, #172]	; (800054c <__init_ram_areas+0xbc>)
 800049e:	4a2c      	ldr	r2, [pc, #176]	; (8000550 <__init_ram_areas+0xc0>)
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80004a0:	4288      	cmp	r0, r1
 80004a2:	d20d      	bcs.n	80004c0 <__init_ram_areas+0x30>
 80004a4:	3a04      	subs	r2, #4
 80004a6:	4603      	mov	r3, r0
      *p = *tp;
 80004a8:	f852 6f04 	ldr.w	r6, [r2, #4]!
 80004ac:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 80004b0:	428b      	cmp	r3, r1
 80004b2:	d3f9      	bcc.n	80004a8 <__init_ram_areas+0x18>
      p++;
 80004b4:	1e4b      	subs	r3, r1, #1
 80004b6:	1a1b      	subs	r3, r3, r0
 80004b8:	f023 0303 	bic.w	r3, r3, #3
 80004bc:	3304      	adds	r3, #4
 80004be:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80004c0:	42b8      	cmp	r0, r7
 80004c2:	d207      	bcs.n	80004d4 <__init_ram_areas+0x44>
      *p = 0;
 80004c4:	3f01      	subs	r7, #1
 80004c6:	2100      	movs	r1, #0
 80004c8:	1a3f      	subs	r7, r7, r0
 80004ca:	f027 0203 	bic.w	r2, r7, #3
 80004ce:	3204      	adds	r2, #4
 80004d0:	f002 fb30 	bl	8002b34 <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 80004d4:	42a5      	cmp	r5, r4
 80004d6:	d005      	beq.n	80004e4 <__init_ram_areas+0x54>
    uint32_t *p = rap->init_area;
 80004d8:	e9d5 2004 	ldrd	r2, r0, [r5, #16]
    while (p < rap->no_init_area) {
 80004dc:	e9d5 1706 	ldrd	r1, r7, [r5, #24]
 80004e0:	3510      	adds	r5, #16
 80004e2:	e7dd      	b.n	80004a0 <__init_ram_areas+0x10>
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

     SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80004e4:	481b      	ldr	r0, [pc, #108]	; (8000554 <__init_ram_areas+0xc4>)
 80004e6:	2300      	movs	r3, #0
 80004e8:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 80004ec:	f3bf 8f4f 	dsb	sy
   __DSB();

    ccsidr = SCB->CCSIDR;
 80004f0:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
                                            /* clean D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 80004f4:	f643 76e0 	movw	r6, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 80004f8:	f3c5 344e 	ubfx	r4, r5, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80004fc:	f3c5 05c9 	ubfx	r5, r5, #3, #10
 8000500:	0164      	lsls	r4, r4, #5
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 8000502:	ea04 0106 	and.w	r1, r4, r6
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000506:	462b      	mov	r3, r5
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 8000508:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 800050c:	3b01      	subs	r3, #1
        SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 800050e:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
      } while (ways-- != 0U);
 8000512:	1c5a      	adds	r2, r3, #1
 8000514:	d1f8      	bne.n	8000508 <__init_ram_areas+0x78>
    } while(sets-- != 0U);
 8000516:	3c20      	subs	r4, #32
 8000518:	f114 0f20 	cmn.w	r4, #32
 800051c:	d1f1      	bne.n	8000502 <__init_ram_areas+0x72>
 800051e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000522:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 8000526:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800052a:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;
 800052e:	2300      	movs	r3, #0
 8000530:	f8c0 3250 	str.w	r3, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000534:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000538:	f3bf 8f6f 	isb	sy
     for self-modifying code.*/
  SCB_CleanDCache();
  SCB_InvalidateICache();
#endif
#endif
}
 800053c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800053e:	bf00      	nop
 8000540:	08002bd8 	.word	0x08002bd8
 8000544:	24000c80 	.word	0x24000c80
 8000548:	24000c80 	.word	0x24000c80
 800054c:	24000c80 	.word	0x24000c80
 8000550:	08002e2c 	.word	0x08002e2c
 8000554:	e000ed00 	.word	0xe000ed00
	...

08000560 <stGetCounter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000564:	6a58      	ldr	r0, [r3, #36]	; 0x24
 * @api
 */
systime_t stGetCounter(void) {

  return st_lld_get_counter();
}
 8000566:	4770      	bx	lr
	...

08000570 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 8000574:	2100      	movs	r1, #0
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000576:	2202      	movs	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000578:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800057a:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800057c:	60da      	str	r2, [r3, #12]
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
 800057e:	4770      	bx	lr

08000580 <stStopAlarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8000580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000584:	2200      	movs	r2, #0
 8000586:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8000588:	4770      	bx	lr
 800058a:	bf00      	nop
 800058c:	0000      	movs	r0, r0
	...

08000590 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000590:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000594:	6358      	str	r0, [r3, #52]	; 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
 8000596:	4770      	bx	lr
	...

080005a0 <iqPutI>:
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 80005a0:	e9d0 3205 	ldrd	r3, r2, [r0, #20]
 80005a4:	4293      	cmp	r3, r2
 80005a6:	d011      	beq.n	80005cc <iqPutI+0x2c>
    iqp->q_counter++;
 80005a8:	6882      	ldr	r2, [r0, #8]
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 80005aa:	b510      	push	{r4, lr}
    iqp->q_counter++;
 80005ac:	3201      	adds	r2, #1
    *iqp->q_wrptr++ = b;
 80005ae:	1c5c      	adds	r4, r3, #1
    iqp->q_counter++;
 80005b0:	6082      	str	r2, [r0, #8]
    *iqp->q_wrptr++ = b;
 80005b2:	6144      	str	r4, [r0, #20]
 80005b4:	7019      	strb	r1, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 80005b6:	e9d0 3204 	ldrd	r3, r2, [r0, #16]
 80005ba:	429a      	cmp	r2, r3
 80005bc:	d301      	bcc.n	80005c2 <iqPutI+0x22>
      iqp->q_wrptr = iqp->q_buffer;
 80005be:	68c3      	ldr	r3, [r0, #12]
 80005c0:	6143      	str	r3, [r0, #20]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 80005c2:	2100      	movs	r1, #0
 80005c4:	f002 fa3c 	bl	8002a40 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);

    return MSG_OK;
 80005c8:	2000      	movs	r0, #0
  }

  return MSG_TIMEOUT;
}
 80005ca:	bd10      	pop	{r4, pc}
  if (!iqIsFullI(iqp)) {
 80005cc:	6882      	ldr	r2, [r0, #8]
 80005ce:	2a00      	cmp	r2, #0
 80005d0:	d0ea      	beq.n	80005a8 <iqPutI+0x8>
  return MSG_TIMEOUT;
 80005d2:	f04f 30ff 	mov.w	r0, #4294967295
}
 80005d6:	4770      	bx	lr
	...

080005e0 <oqGetI>:
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 80005e0:	e9d0 2305 	ldrd	r2, r3, [r0, #20]
 80005e4:	429a      	cmp	r2, r3
 80005e6:	d010      	beq.n	800060a <oqGetI+0x2a>
    uint8_t b;

    oqp->q_counter++;
 80005e8:	6882      	ldr	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 80005ea:	1c59      	adds	r1, r3, #1
    oqp->q_counter++;
 80005ec:	3201      	adds	r2, #1
msg_t oqGetI(output_queue_t *oqp) {
 80005ee:	b510      	push	{r4, lr}
    b = *oqp->q_rdptr++;
 80005f0:	6181      	str	r1, [r0, #24]
    oqp->q_counter++;
 80005f2:	6082      	str	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 80005f4:	781c      	ldrb	r4, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 80005f6:	6903      	ldr	r3, [r0, #16]
 80005f8:	4299      	cmp	r1, r3
 80005fa:	d301      	bcc.n	8000600 <oqGetI+0x20>
      oqp->q_rdptr = oqp->q_buffer;
 80005fc:	68c3      	ldr	r3, [r0, #12]
 80005fe:	6183      	str	r3, [r0, #24]
 8000600:	2100      	movs	r1, #0
 8000602:	f002 fa1d 	bl	8002a40 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

    return (msg_t)b;
 8000606:	4620      	mov	r0, r4
  }

  return MSG_TIMEOUT;
}
 8000608:	bd10      	pop	{r4, pc}
  if (!oqIsEmptyI(oqp)) {
 800060a:	6882      	ldr	r2, [r0, #8]
 800060c:	2a00      	cmp	r2, #0
 800060e:	d0eb      	beq.n	80005e8 <oqGetI+0x8>
  return MSG_TIMEOUT;
 8000610:	f04f 30ff 	mov.w	r0, #4294967295
}
 8000614:	4770      	bx	lr
 8000616:	bf00      	nop
	...

08000620 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000620:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000622:	6943      	ldr	r3, [r0, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000624:	4604      	mov	r4, r0
 8000626:	460d      	mov	r5, r1
  if (iqIsEmptyI(&sdp->iqueue))
 8000628:	b13b      	cbz	r3, 800063a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 800062a:	4629      	mov	r1, r5
 800062c:	f104 000c 	add.w	r0, r4, #12
 8000630:	f7ff ffb6 	bl	80005a0 <iqPutI>
 8000634:	2800      	cmp	r0, #0
 8000636:	db0b      	blt.n	8000650 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
 8000638:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800063a:	2104      	movs	r1, #4
 800063c:	4408      	add	r0, r1
 800063e:	f002 fa0f 	bl	8002a60 <chEvtBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8000642:	4629      	mov	r1, r5
 8000644:	f104 000c 	add.w	r0, r4, #12
 8000648:	f7ff ffaa 	bl	80005a0 <iqPutI>
 800064c:	2800      	cmp	r0, #0
 800064e:	daf3      	bge.n	8000638 <sdIncomingDataI+0x18>
 8000650:	1d20      	adds	r0, r4, #4
 8000652:	f44f 6100 	mov.w	r1, #2048	; 0x800
}
 8000656:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800065a:	f002 ba01 	b.w	8002a60 <chEvtBroadcastFlagsI>
 800065e:	bf00      	nop

08000660 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8000660:	b570      	push	{r4, r5, r6, lr}
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8000662:	2302      	movs	r3, #2

  /* Resetting internal state.*/
  usbp->status        = 0;
 8000664:	2500      	movs	r5, #0
void _usb_reset(USBDriver *usbp) {
 8000666:	4604      	mov	r4, r0
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8000668:	2224      	movs	r2, #36	; 0x24
  usbp->state         = USB_READY;
 800066a:	7003      	strb	r3, [r0, #0]
    usbp->epc[i] = NULL;
 800066c:	4629      	mov	r1, r5
  usbp->status        = 0;
 800066e:	f8c0 5088 	str.w	r5, [r0, #136]	; 0x88
    usbp->epc[i] = NULL;
 8000672:	300c      	adds	r0, #12
  usbp->transmitting  = 0;
 8000674:	f840 5c04 	str.w	r5, [r0, #-4]
    usbp->epc[i] = NULL;
 8000678:	f002 fa5c 	bl	8002b34 <memset>

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_STP_WAITING;

  /* Low level reset.*/
  usb_lld_reset(usbp);
 800067c:	4620      	mov	r0, r4
  usbp->ep0state = USB_EP0_STP_WAITING;
 800067e:	f884 5070 	strb.w	r5, [r4, #112]	; 0x70
  usb_lld_reset(usbp);
 8000682:	f000 ffbd 	bl	8001600 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8000686:	6863      	ldr	r3, [r4, #4]
 8000688:	681b      	ldr	r3, [r3, #0]
 800068a:	b123      	cbz	r3, 8000696 <_usb_reset+0x36>
 800068c:	4629      	mov	r1, r5
 800068e:	4620      	mov	r0, r4
}
 8000690:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8000694:	4718      	bx	r3
}
 8000696:	bd70      	pop	{r4, r5, r6, pc}
	...

080006a0 <_usb_suspend>:
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {

  /* It could happen that multiple suspend events are triggered.*/
  if (usbp->state != USB_SUSPENDED) {
 80006a0:	7803      	ldrb	r3, [r0, #0]
 80006a2:	2b05      	cmp	r3, #5
 80006a4:	d00d      	beq.n	80006c2 <_usb_suspend+0x22>

    /* State transition, saving the current state.*/
    usbp->saved_state = usbp->state;
    usbp->state       = USB_SUSPENDED;
 80006a6:	2105      	movs	r1, #5

    /* Notification of suspend event.*/
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80006a8:	6842      	ldr	r2, [r0, #4]
    usbp->saved_state = usbp->state;
 80006aa:	f880 308c 	strb.w	r3, [r0, #140]	; 0x8c
    usbp->state       = USB_SUSPENDED;
 80006ae:	7001      	strb	r1, [r0, #0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80006b0:	6813      	ldr	r3, [r2, #0]
void _usb_suspend(USBDriver *usbp) {
 80006b2:	b510      	push	{r4, lr}
 80006b4:	4604      	mov	r4, r0
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80006b6:	b10b      	cbz	r3, 80006bc <_usb_suspend+0x1c>
 80006b8:	2104      	movs	r1, #4
 80006ba:	4798      	blx	r3

    /* Terminating all pending transactions.*/
    usbp->transmitting  = 0;
 80006bc:	2300      	movs	r3, #0
 80006be:	60a3      	str	r3, [r4, #8]
        }
      }
    }
  #endif
  }
}
 80006c0:	bd10      	pop	{r4, pc}
 80006c2:	4770      	bx	lr
	...

080006d0 <_usb_wakeup>:
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* It could happen that multiple waakeup events are triggered.*/
  if (usbp->state == USB_SUSPENDED) {
 80006d0:	7801      	ldrb	r1, [r0, #0]
 80006d2:	2905      	cmp	r1, #5
 80006d4:	d000      	beq.n	80006d8 <_usb_wakeup+0x8>
    usbp->state = usbp->saved_state;

    /* Notification of suspend event.*/
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
  }
}
 80006d6:	4770      	bx	lr
    usbp->state = usbp->saved_state;
 80006d8:	f890 c08c 	ldrb.w	ip, [r0, #140]	; 0x8c
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80006dc:	6842      	ldr	r2, [r0, #4]
    usbp->state = usbp->saved_state;
 80006de:	f880 c000 	strb.w	ip, [r0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80006e2:	6813      	ldr	r3, [r2, #0]
 80006e4:	2b00      	cmp	r3, #0
 80006e6:	d0f6      	beq.n	80006d6 <_usb_wakeup+0x6>
 80006e8:	4718      	bx	r3
 80006ea:	bf00      	nop
 80006ec:	0000      	movs	r0, r0
	...

080006f0 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80006f0:	b570      	push	{r4, r5, r6, lr}
  size_t max;

  /* Is the EP0 state machine in the correct state for handling setup
     packets?*/
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 80006f2:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80006f6:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 80006f8:	b113      	cbz	r3, 8000700 <_usb_ep0setup+0x10>
    /* This is unexpected could require handling with a warning event.*/
    /* CHTODO: handling here.*/

    /* Resetting the EP0 state machine and going ahead.*/
    usbp->ep0state = USB_EP0_STP_WAITING;
 80006fa:	2300      	movs	r3, #0
 80006fc:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
  }

  /* Reading the setup data into the driver buffer.*/
  usbReadSetup(usbp, ep, usbp->setup);
 8000700:	f104 0280 	add.w	r2, r4, #128	; 0x80
 8000704:	4620      	mov	r0, r4
 8000706:	f001 f81b 	bl	8001740 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 800070a:	6863      	ldr	r3, [r4, #4]
 800070c:	689b      	ldr	r3, [r3, #8]
 800070e:	b353      	cbz	r3, 8000766 <_usb_ep0setup+0x76>
      !(usbp->config->requests_hook_cb(usbp))) {
 8000710:	4620      	mov	r0, r4
 8000712:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 8000714:	b338      	cbz	r0, 8000766 <_usb_ep0setup+0x76>
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8000716:	6fa5      	ldr	r5, [r4, #120]	; 0x78
 8000718:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
  max = (size_t)get_hword(&usbp->setup[6]);
 800071c:	f8b4 2086 	ldrh.w	r2, [r4, #134]	; 0x86
  if (usbp->ep0n > max) {
 8000720:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8000722:	bf2c      	ite	cs
 8000724:	462a      	movcs	r2, r5
    usbp->ep0n = max;
 8000726:	67a2      	strcc	r2, [r4, #120]	; 0x78
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8000728:	0619      	lsls	r1, r3, #24
 800072a:	f100 80da 	bmi.w	80008e2 <_usb_ep0setup+0x1f2>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 800072e:	2a00      	cmp	r2, #0
 8000730:	f000 808d 	beq.w	800084e <_usb_ep0setup+0x15e>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_OUT_RX;
 8000734:	2215      	movs	r2, #21
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000736:	2330      	movs	r3, #48	; 0x30
 8000738:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 800073c:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000740:	8962      	ldrh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 8000742:	4620      	mov	r0, r4
  osp = usbp->epc[ep]->out_state;
 8000744:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000746:	f042 0201 	orr.w	r2, r2, #1
  osp = usbp->epc[ep]->out_state;
 800074a:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800074c:	8162      	strh	r2, [r4, #10]
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 800074e:	e9d4 511d 	ldrd	r5, r1, [r4, #116]	; 0x74
  osp->rxcnt  = 0;
 8000752:	2400      	movs	r4, #0
  osp->rxsize = n;
 8000754:	6019      	str	r1, [r3, #0]
  osp->rxbuf  = buf;
 8000756:	609d      	str	r5, [r3, #8]
  usb_lld_start_out(usbp, ep);
 8000758:	4621      	mov	r1, r4
  osp->rxcnt  = 0;
 800075a:	605c      	str	r4, [r3, #4]
  usb_lld_start_out(usbp, ep);
 800075c:	f001 f800 	bl	8001760 <usb_lld_start_out>
 8000760:	f384 8811 	msr	BASEPRI, r4
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8000764:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8000766:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 800076a:	f013 0660 	ands.w	r6, r3, #96	; 0x60
 800076e:	4618      	mov	r0, r3
 8000770:	d11c      	bne.n	80007ac <_usb_ep0setup+0xbc>
           ((uint32_t)usbp->setup[1] << 8U))) {
 8000772:	f894 2081 	ldrb.w	r2, [r4, #129]	; 0x81
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8000776:	f003 057f 	and.w	r5, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 800077a:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800077e:	f240 3202 	movw	r2, #770	; 0x302
 8000782:	4295      	cmp	r5, r2
 8000784:	f000 8151 	beq.w	8000a2a <_usb_ep0setup+0x33a>
 8000788:	d840      	bhi.n	800080c <_usb_ep0setup+0x11c>
 800078a:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800078e:	f000 8108 	beq.w	80009a2 <_usb_ep0setup+0x2b2>
 8000792:	d91d      	bls.n	80007d0 <_usb_ep0setup+0xe0>
 8000794:	f5b5 7f81 	cmp.w	r5, #258	; 0x102
 8000798:	f000 8112 	beq.w	80009c0 <_usb_ep0setup+0x2d0>
 800079c:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 80007a0:	d104      	bne.n	80007ac <_usb_ep0setup+0xbc>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80007a2:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 80007a6:	2b01      	cmp	r3, #1
 80007a8:	f000 80d3 	beq.w	8000952 <_usb_ep0setup+0x262>
      usb_lld_stall_in(usbp, 0);
 80007ac:	2100      	movs	r1, #0
 80007ae:	4620      	mov	r0, r4
 80007b0:	f001 fb4e 	bl	8001e50 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 80007b4:	2100      	movs	r1, #0
 80007b6:	4620      	mov	r0, r4
 80007b8:	f001 fb3a 	bl	8001e30 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80007bc:	6863      	ldr	r3, [r4, #4]
 80007be:	681b      	ldr	r3, [r3, #0]
 80007c0:	b113      	cbz	r3, 80007c8 <_usb_ep0setup+0xd8>
 80007c2:	2106      	movs	r1, #6
 80007c4:	4620      	mov	r0, r4
 80007c6:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 80007c8:	2306      	movs	r3, #6
 80007ca:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 80007ce:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80007d0:	2d01      	cmp	r5, #1
 80007d2:	d061      	beq.n	8000898 <_usb_ep0setup+0x1a8>
 80007d4:	2d02      	cmp	r5, #2
 80007d6:	d151      	bne.n	800087c <_usb_ep0setup+0x18c>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80007d8:	f994 3084 	ldrsb.w	r3, [r4, #132]	; 0x84
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 80007dc:	4620      	mov	r0, r4
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80007de:	f894 1084 	ldrb.w	r1, [r4, #132]	; 0x84
 80007e2:	2b00      	cmp	r3, #0
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 80007e4:	f001 010f 	and.w	r1, r1, #15
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80007e8:	f2c0 80ac 	blt.w	8000944 <_usb_ep0setup+0x254>
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 80007ec:	f000 ff88 	bl	8001700 <usb_lld_get_status_out>
 80007f0:	2801      	cmp	r0, #1
 80007f2:	f000 80ac 	beq.w	800094e <_usb_ep0setup+0x25e>
 80007f6:	2802      	cmp	r0, #2
 80007f8:	d1d8      	bne.n	80007ac <_usb_ep0setup+0xbc>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 80007fa:	499a      	ldr	r1, [pc, #616]	; (8000a64 <_usb_ep0setup+0x374>)
 80007fc:	2302      	movs	r3, #2
 80007fe:	2200      	movs	r2, #0
 8000800:	e9c4 131d 	strd	r1, r3, [r4, #116]	; 0x74
 8000804:	67e2      	str	r2, [r4, #124]	; 0x7c
        return true;
 8000806:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 800080a:	e787      	b.n	800071c <_usb_ep0setup+0x2c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800080c:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 8000810:	f000 8103 	beq.w	8000a1a <_usb_ep0setup+0x32a>
 8000814:	d947      	bls.n	80008a6 <_usb_ep0setup+0x1b6>
 8000816:	f5b5 6f10 	cmp.w	r5, #2304	; 0x900
 800081a:	d139      	bne.n	8000890 <_usb_ep0setup+0x1a0>
      if (usbp->state == USB_ACTIVE) {
 800081c:	7823      	ldrb	r3, [r4, #0]
 800081e:	2b04      	cmp	r3, #4
 8000820:	f000 80a1 	beq.w	8000966 <_usb_ep0setup+0x276>
      if (usbp->setup[2] != 0U) {
 8000824:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8000828:	b14b      	cbz	r3, 800083e <_usb_ep0setup+0x14e>
        usbp->state = USB_ACTIVE;
 800082a:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800082c:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 800082e:	f884 308b 	strb.w	r3, [r4, #139]	; 0x8b
        usbp->state = USB_ACTIVE;
 8000832:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8000834:	6813      	ldr	r3, [r2, #0]
 8000836:	b113      	cbz	r3, 800083e <_usb_ep0setup+0x14e>
 8000838:	2102      	movs	r1, #2
 800083a:	4620      	mov	r0, r4
 800083c:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800083e:	2300      	movs	r3, #0
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8000840:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8000844:	e9c4 331d 	strd	r3, r3, [r4, #116]	; 0x74
 8000848:	67e3      	str	r3, [r4, #124]	; 0x7c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800084a:	0603      	lsls	r3, r0, #24
 800084c:	d463      	bmi.n	8000916 <_usb_ep0setup+0x226>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 800084e:	220b      	movs	r2, #11
 8000850:	2330      	movs	r3, #48	; 0x30
 8000852:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 8000856:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800085a:	8922      	ldrh	r2, [r4, #8]
  isp->txbuf  = buf;
 800085c:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
 800085e:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_in(usbp, ep);
 8000860:	4620      	mov	r0, r4
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000862:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_in(usbp, ep);
 8000866:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 8000868:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800086a:	8122      	strh	r2, [r4, #8]
  isp->txbuf  = buf;
 800086c:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 800086e:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8000872:	f001 f80d 	bl	8001890 <usb_lld_start_in>
 8000876:	f385 8811 	msr	BASEPRI, r5
}
 800087a:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800087c:	2d00      	cmp	r5, #0
 800087e:	d195      	bne.n	80007ac <_usb_ep0setup+0xbc>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8000880:	2202      	movs	r2, #2
 8000882:	f104 0188 	add.w	r1, r4, #136	; 0x88
 8000886:	67e5      	str	r5, [r4, #124]	; 0x7c
 8000888:	6761      	str	r1, [r4, #116]	; 0x74
 800088a:	4615      	mov	r5, r2
 800088c:	67a2      	str	r2, [r4, #120]	; 0x78
    return true;
 800088e:	e745      	b.n	800071c <_usb_ep0setup+0x2c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8000890:	f640 4202 	movw	r2, #3074	; 0xc02
 8000894:	4295      	cmp	r5, r2
 8000896:	d189      	bne.n	80007ac <_usb_ep0setup+0xbc>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8000898:	2502      	movs	r5, #2
 800089a:	4973      	ldr	r1, [pc, #460]	; (8000a68 <_usb_ep0setup+0x378>)
 800089c:	2200      	movs	r2, #0
 800089e:	e9c4 151d 	strd	r1, r5, [r4, #116]	; 0x74
 80008a2:	67e2      	str	r2, [r4, #124]	; 0x7c
    return true;
 80008a4:	e73a      	b.n	800071c <_usb_ep0setup+0x2c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80008a6:	f5b5 6fa0 	cmp.w	r5, #1280	; 0x500
 80008aa:	f000 809f 	beq.w	80009ec <_usb_ep0setup+0x2fc>
 80008ae:	f5a5 65c0 	sub.w	r5, r5, #1536	; 0x600
 80008b2:	2d01      	cmp	r5, #1
 80008b4:	f63f af7a 	bhi.w	80007ac <_usb_ep0setup+0xbc>
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80008b8:	6861      	ldr	r1, [r4, #4]
 80008ba:	4620      	mov	r0, r4
 80008bc:	f8b4 3084 	ldrh.w	r3, [r4, #132]	; 0x84
 80008c0:	684d      	ldr	r5, [r1, #4]
 80008c2:	f894 2082 	ldrb.w	r2, [r4, #130]	; 0x82
 80008c6:	f894 1083 	ldrb.w	r1, [r4, #131]	; 0x83
 80008ca:	47a8      	blx	r5
    if (dp == NULL) {
 80008cc:	2800      	cmp	r0, #0
 80008ce:	f43f af6d 	beq.w	80007ac <_usb_ep0setup+0xbc>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80008d2:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 80008d6:	e9d0 5200 	ldrd	r5, r2, [r0]
 80008da:	67e6      	str	r6, [r4, #124]	; 0x7c
 80008dc:	e9c4 251d 	strd	r2, r5, [r4, #116]	; 0x74
    return true;
 80008e0:	e71c      	b.n	800071c <_usb_ep0setup+0x2c>
    if (usbp->ep0n != 0U) {
 80008e2:	b1c2      	cbz	r2, 8000916 <_usb_ep0setup+0x226>
      usbp->ep0state = USB_EP0_IN_TX;
 80008e4:	2209      	movs	r2, #9
 80008e6:	2330      	movs	r3, #48	; 0x30
 80008e8:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 80008ec:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80008f0:	8922      	ldrh	r2, [r4, #8]
  usb_lld_start_in(usbp, ep);
 80008f2:	4620      	mov	r0, r4
  isp = usbp->epc[ep]->in_state;
 80008f4:	68e3      	ldr	r3, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80008f6:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
 80008fa:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80008fc:	8122      	strh	r2, [r4, #8]
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80008fe:	e9d4 511d 	ldrd	r5, r1, [r4, #116]	; 0x74
  isp->txcnt  = 0;
 8000902:	2400      	movs	r4, #0
  isp->txsize = n;
 8000904:	6019      	str	r1, [r3, #0]
  isp->txbuf  = buf;
 8000906:	609d      	str	r5, [r3, #8]
  usb_lld_start_in(usbp, ep);
 8000908:	4621      	mov	r1, r4
  isp->txcnt  = 0;
 800090a:	605c      	str	r4, [r3, #4]
  usb_lld_start_in(usbp, ep);
 800090c:	f000 ffc0 	bl	8001890 <usb_lld_start_in>
 8000910:	f384 8811 	msr	BASEPRI, r4
}
 8000914:	bd70      	pop	{r4, r5, r6, pc}
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8000916:	2214      	movs	r2, #20
 8000918:	2330      	movs	r3, #48	; 0x30
 800091a:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 800091e:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000922:	8962      	ldrh	r2, [r4, #10]
  osp->rxbuf  = buf;
 8000924:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
 8000926:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
 8000928:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800092a:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_out(usbp, ep);
 800092e:	4629      	mov	r1, r5
  osp = usbp->epc[ep]->out_state;
 8000930:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000932:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
 8000934:	609d      	str	r5, [r3, #8]
  osp->rxcnt  = 0;
 8000936:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_out(usbp, ep);
 800093a:	f000 ff11 	bl	8001760 <usb_lld_start_out>
 800093e:	f385 8811 	msr	BASEPRI, r5
}
 8000942:	bd70      	pop	{r4, r5, r6, pc}
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8000944:	f000 feec 	bl	8001720 <usb_lld_get_status_in>
 8000948:	2801      	cmp	r0, #1
 800094a:	f47f af54 	bne.w	80007f6 <_usb_ep0setup+0x106>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800094e:	4947      	ldr	r1, [pc, #284]	; (8000a6c <_usb_ep0setup+0x37c>)
 8000950:	e754      	b.n	80007fc <_usb_ep0setup+0x10c>
      usbp->status |= 2U;
 8000952:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8000956:	67e6      	str	r6, [r4, #124]	; 0x7c
      usbp->status |= 2U;
 8000958:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800095c:	e9c4 661d 	strd	r6, r6, [r4, #116]	; 0x74
      usbp->status |= 2U;
 8000960:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
      return true;
 8000964:	e771      	b.n	800084a <_usb_ep0setup+0x15a>
 8000966:	2330      	movs	r3, #48	; 0x30
 8000968:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting &= 1U;
 800096c:	68a3      	ldr	r3, [r4, #8]
    usbp->epc[i] = NULL;
 800096e:	2220      	movs	r2, #32
 8000970:	4631      	mov	r1, r6
 8000972:	f104 0010 	add.w	r0, r4, #16
  usbp->transmitting &= 1U;
 8000976:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
 800097a:	60a3      	str	r3, [r4, #8]
    usbp->epc[i] = NULL;
 800097c:	f002 f8da 	bl	8002b34 <memset>
  usb_lld_disable_endpoints(usbp);
 8000980:	4620      	mov	r0, r4
 8000982:	f000 feb5 	bl	80016f0 <usb_lld_disable_endpoints>
 8000986:	f386 8811 	msr	BASEPRI, r6
        usbp->state = USB_SELECTED;
 800098a:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 800098c:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
 800098e:	f884 608b 	strb.w	r6, [r4, #139]	; 0x8b
        usbp->state = USB_SELECTED;
 8000992:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8000994:	681b      	ldr	r3, [r3, #0]
 8000996:	2b00      	cmp	r3, #0
 8000998:	f43f af44 	beq.w	8000824 <_usb_ep0setup+0x134>
 800099c:	4620      	mov	r0, r4
 800099e:	4798      	blx	r3
 80009a0:	e740      	b.n	8000824 <_usb_ep0setup+0x134>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80009a2:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 80009a6:	2b01      	cmp	r3, #1
 80009a8:	f47f af00 	bne.w	80007ac <_usb_ep0setup+0xbc>
      usbp->status &= ~2U;
 80009ac:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80009b0:	67e6      	str	r6, [r4, #124]	; 0x7c
      usbp->status &= ~2U;
 80009b2:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80009b6:	e9c4 661d 	strd	r6, r6, [r4, #116]	; 0x74
      usbp->status &= ~2U;
 80009ba:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
      return true;
 80009be:	e744      	b.n	800084a <_usb_ep0setup+0x15a>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80009c0:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 80009c4:	2b00      	cmp	r3, #0
 80009c6:	f47f aef1 	bne.w	80007ac <_usb_ep0setup+0xbc>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80009ca:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
 80009ce:	f013 010f 	ands.w	r1, r3, #15
 80009d2:	d006      	beq.n	80009e2 <_usb_ep0setup+0x2f2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80009d4:	061e      	lsls	r6, r3, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80009d6:	4620      	mov	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80009d8:	d439      	bmi.n	8000a4e <_usb_ep0setup+0x35e>
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 80009da:	f001 fa49 	bl	8001e70 <usb_lld_clear_out>
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80009de:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80009e2:	2300      	movs	r3, #0
 80009e4:	e9c4 331d 	strd	r3, r3, [r4, #116]	; 0x74
 80009e8:	67e3      	str	r3, [r4, #124]	; 0x7c
    return true;
 80009ea:	e72e      	b.n	800084a <_usb_ep0setup+0x15a>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 80009ec:	f8b4 3080 	ldrh.w	r3, [r4, #128]	; 0x80
 80009f0:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80009f4:	d1f5      	bne.n	80009e2 <_usb_ep0setup+0x2f2>
  usbp->address = usbp->setup[2];
 80009f6:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
  usb_lld_set_address(usbp);
 80009fa:	4620      	mov	r0, r4
  usbp->address = usbp->setup[2];
 80009fc:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
  usb_lld_set_address(usbp);
 8000a00:	f000 fe66 	bl	80016d0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8000a04:	6863      	ldr	r3, [r4, #4]
 8000a06:	681b      	ldr	r3, [r3, #0]
 8000a08:	b113      	cbz	r3, 8000a10 <_usb_ep0setup+0x320>
 8000a0a:	2101      	movs	r1, #1
 8000a0c:	4620      	mov	r0, r4
 8000a0e:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8000a10:	2303      	movs	r3, #3
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8000a12:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
  usbp->state = USB_SELECTED;
 8000a16:	7023      	strb	r3, [r4, #0]
}
 8000a18:	e7e3      	b.n	80009e2 <_usb_ep0setup+0x2f2>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8000a1a:	2201      	movs	r2, #1
 8000a1c:	f104 018b 	add.w	r1, r4, #139	; 0x8b
 8000a20:	67e6      	str	r6, [r4, #124]	; 0x7c
 8000a22:	4615      	mov	r5, r2
 8000a24:	e9c4 121d 	strd	r1, r2, [r4, #116]	; 0x74
    return true;
 8000a28:	e678      	b.n	800071c <_usb_ep0setup+0x2c>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8000a2a:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8000a2e:	2b00      	cmp	r3, #0
 8000a30:	f47f aebc 	bne.w	80007ac <_usb_ep0setup+0xbc>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8000a34:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
 8000a38:	f013 010f 	ands.w	r1, r3, #15
 8000a3c:	d0d1      	beq.n	80009e2 <_usb_ep0setup+0x2f2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8000a3e:	061d      	lsls	r5, r3, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8000a40:	4620      	mov	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8000a42:	d409      	bmi.n	8000a58 <_usb_ep0setup+0x368>
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8000a44:	f001 f9f4 	bl	8001e30 <usb_lld_stall_out>
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8000a48:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
 8000a4c:	e7c9      	b.n	80009e2 <_usb_ep0setup+0x2f2>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8000a4e:	f001 fa1f 	bl	8001e90 <usb_lld_clear_in>
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8000a52:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
 8000a56:	e7c4      	b.n	80009e2 <_usb_ep0setup+0x2f2>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8000a58:	f001 f9fa 	bl	8001e50 <usb_lld_stall_in>
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8000a5c:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
 8000a60:	e7bf      	b.n	80009e2 <_usb_ep0setup+0x2f2>
 8000a62:	bf00      	nop
 8000a64:	08002c58 	.word	0x08002c58
 8000a68:	08002c60 	.word	0x08002c60
 8000a6c:	08002c5c 	.word	0x08002c5c

08000a70 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8000a70:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8000a72:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8000a76:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8000a78:	2b15      	cmp	r3, #21
 8000a7a:	d827      	bhi.n	8000acc <_usb_ep0in+0x5c>
 8000a7c:	e8df f003 	tbb	[pc, r3]
 8000a80:	26262627 	.word	0x26262627
 8000a84:	26272626 	.word	0x26272626
 8000a88:	38100b26 	.word	0x38100b26
 8000a8c:	26262626 	.word	0x26262626
 8000a90:	26262626 	.word	0x26262626
 8000a94:	2727      	.short	0x2727
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8000a96:	6f85      	ldr	r5, [r0, #120]	; 0x78
    max = (size_t)get_hword(&usbp->setup[6]);
 8000a98:	f8b0 3086 	ldrh.w	r3, [r0, #134]	; 0x86
    if ((usbp->ep0n < max) &&
 8000a9c:	429d      	cmp	r5, r3
 8000a9e:	d32e      	bcc.n	8000afe <_usb_ep0in+0x8e>
      return;
    }
    /* Falls through.*/
  case USB_EP0_IN_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8000aa0:	2214      	movs	r2, #20
 8000aa2:	2330      	movs	r3, #48	; 0x30
 8000aa4:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 8000aa8:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000aac:	8962      	ldrh	r2, [r4, #10]
  osp->rxbuf  = buf;
 8000aae:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
 8000ab0:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
 8000ab2:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000ab4:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_out(usbp, ep);
 8000ab8:	4629      	mov	r1, r5
  osp = usbp->epc[ep]->out_state;
 8000aba:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000abc:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
 8000abe:	609d      	str	r5, [r3, #8]
  osp->rxcnt  = 0;
 8000ac0:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_out(usbp, ep);
 8000ac4:	f000 fe4c 	bl	8001760 <usb_lld_start_out>
 8000ac8:	f385 8811 	msr	BASEPRI, r5
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8000acc:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_stall_in(usbp, 0);
 8000ace:	2100      	movs	r1, #0
 8000ad0:	f001 f9be 	bl	8001e50 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8000ad4:	2100      	movs	r1, #0
 8000ad6:	4620      	mov	r0, r4
 8000ad8:	f001 f9aa 	bl	8001e30 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8000adc:	6863      	ldr	r3, [r4, #4]
 8000ade:	681b      	ldr	r3, [r3, #0]
 8000ae0:	b113      	cbz	r3, 8000ae8 <_usb_ep0in+0x78>
 8000ae2:	2106      	movs	r1, #6
 8000ae4:	4620      	mov	r0, r4
 8000ae6:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8000ae8:	2306      	movs	r3, #6
 8000aea:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8000aee:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
 8000af0:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 8000af2:	b103      	cbz	r3, 8000af6 <_usb_ep0in+0x86>
      usbp->ep0endcb(usbp);
 8000af4:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 8000af6:	2300      	movs	r3, #0
 8000af8:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8000afc:	bd38      	pop	{r3, r4, r5, pc}
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8000afe:	68c3      	ldr	r3, [r0, #12]
 8000b00:	8a1b      	ldrh	r3, [r3, #16]
 8000b02:	fbb5 f2f3 	udiv	r2, r5, r3
 8000b06:	fb03 5512 	mls	r5, r3, r2, r5
    if ((usbp->ep0n < max) &&
 8000b0a:	2d00      	cmp	r5, #0
 8000b0c:	d1c8      	bne.n	8000aa0 <_usb_ep0in+0x30>
 8000b0e:	2330      	movs	r3, #48	; 0x30
 8000b10:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000b14:	8902      	ldrh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
 8000b16:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 8000b18:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000b1a:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
 8000b1e:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000b20:	8102      	strh	r2, [r0, #8]
  isp->txbuf  = buf;
 8000b22:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8000b24:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8000b28:	f000 feb2 	bl	8001890 <usb_lld_start_in>
 8000b2c:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 8000b30:	230a      	movs	r3, #10
 8000b32:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8000b36:	bd38      	pop	{r3, r4, r5, pc}
	...

08000b40 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8000b40:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8000b42:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8000b46:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8000b48:	2b15      	cmp	r3, #21
 8000b4a:	d821      	bhi.n	8000b90 <_usb_ep0out+0x50>
 8000b4c:	e8df f003 	tbb	[pc, r3]
 8000b50:	20202021 	.word	0x20202021
 8000b54:	20212020 	.word	0x20212020
 8000b58:	21212120 	.word	0x21212120
 8000b5c:	20202020 	.word	0x20202020
 8000b60:	20202020 	.word	0x20202020
 8000b64:	0b32      	.short	0x0b32
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8000b66:	220b      	movs	r2, #11
 8000b68:	2330      	movs	r3, #48	; 0x30
 8000b6a:	f880 2070 	strb.w	r2, [r0, #112]	; 0x70
 8000b6e:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000b72:	8902      	ldrh	r2, [r0, #8]
  isp->txbuf  = buf;
 8000b74:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
 8000b76:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000b78:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_in(usbp, ep);
 8000b7c:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 8000b7e:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000b80:	8102      	strh	r2, [r0, #8]
  isp->txbuf  = buf;
 8000b82:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8000b84:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8000b88:	f000 fe82 	bl	8001890 <usb_lld_start_in>
 8000b8c:	f385 8811 	msr	BASEPRI, r5
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8000b90:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_stall_in(usbp, 0);
 8000b92:	2100      	movs	r1, #0
 8000b94:	f001 f95c 	bl	8001e50 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8000b98:	2100      	movs	r1, #0
 8000b9a:	4620      	mov	r0, r4
 8000b9c:	f001 f948 	bl	8001e30 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8000ba0:	6863      	ldr	r3, [r4, #4]
 8000ba2:	681b      	ldr	r3, [r3, #0]
 8000ba4:	b113      	cbz	r3, 8000bac <_usb_ep0out+0x6c>
 8000ba6:	2106      	movs	r1, #6
 8000ba8:	4620      	mov	r0, r4
 8000baa:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8000bac:	2306      	movs	r3, #6
 8000bae:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8000bb2:	bd38      	pop	{r3, r4, r5, pc}
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8000bb4:	68c3      	ldr	r3, [r0, #12]
 8000bb6:	699b      	ldr	r3, [r3, #24]
 8000bb8:	685b      	ldr	r3, [r3, #4]
 8000bba:	2b00      	cmp	r3, #0
 8000bbc:	d1e8      	bne.n	8000b90 <_usb_ep0out+0x50>
    if (usbp->ep0endcb != NULL) {
 8000bbe:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 8000bc0:	b103      	cbz	r3, 8000bc4 <_usb_ep0out+0x84>
      usbp->ep0endcb(usbp);
 8000bc2:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 8000bc4:	2300      	movs	r3, #0
 8000bc6:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8000bca:	bd38      	pop	{r3, r4, r5, pc}
 8000bcc:	0000      	movs	r0, r0
	...

08000bd0 <Vector104>:
/**
 * @brief   SDMMC1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDMMC1_HANDLER) {
 8000bd0:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8000bd2:	4c07      	ldr	r4, [pc, #28]	; (8000bf0 <Vector104+0x20>)
 8000bd4:	4620      	mov	r0, r4
 8000bd6:	f001 fd9b 	bl	8002710 <__trace_isr_enter>

#if HAL_USE_SDC
#if STM32_SDC_USE_SDMMC1
  sdc_lld_serve_interrupt(&SDCD1);
 8000bda:	4806      	ldr	r0, [pc, #24]	; (8000bf4 <Vector104+0x24>)
 8000bdc:	f001 f968 	bl	8001eb0 <sdc_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000be0:	4620      	mov	r0, r4
 8000be2:	f001 fdad 	bl	8002740 <__trace_isr_leave>
}
 8000be6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000bea:	f001 bf79 	b.w	8002ae0 <__port_irq_epilogue>
 8000bee:	bf00      	nop
 8000bf0:	08002c88 	.word	0x08002c88
 8000bf4:	240001b4 	.word	0x240001b4
	...

08000c00 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000c00:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8000c02:	4c07      	ldr	r4, [pc, #28]	; (8000c20 <VectorD4+0x20>)
 8000c04:	4620      	mov	r0, r4
 8000c06:	f001 fd83 	bl	8002710 <__trace_isr_enter>

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_USART1
  sd_lld_serve_interrupt(&SD1);
 8000c0a:	4806      	ldr	r0, [pc, #24]	; (8000c24 <VectorD4+0x24>)
 8000c0c:	f001 fb78 	bl	8002300 <sd_lld_serve_interrupt>
#if STM32_UART_USE_USART1
  uart_lld_serve_interrupt(&UARTD1);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000c10:	4620      	mov	r0, r4
 8000c12:	f001 fd95 	bl	8002740 <__trace_isr_leave>
}
 8000c16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000c1a:	f001 bf61 	b.w	8002ae0 <__port_irq_epilogue>
 8000c1e:	bf00      	nop
 8000c20:	08002c7c 	.word	0x08002c7c
 8000c24:	24000330 	.word	0x24000330
	...

08000c30 <Vector114>:
/**
 * @brief   UART5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART5_HANDLER) {
 8000c30:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8000c32:	4c07      	ldr	r4, [pc, #28]	; (8000c50 <Vector114+0x20>)
 8000c34:	4620      	mov	r0, r4
 8000c36:	f001 fd6b 	bl	8002710 <__trace_isr_enter>

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_UART5
  sd_lld_serve_interrupt(&SD5);
 8000c3a:	4806      	ldr	r0, [pc, #24]	; (8000c54 <Vector114+0x24>)
 8000c3c:	f001 fb60 	bl	8002300 <sd_lld_serve_interrupt>
#if STM32_UART_USE_UART5
  uart_lld_serve_interrupt(&UARTD5);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000c40:	4620      	mov	r0, r4
 8000c42:	f001 fd7d 	bl	8002740 <__trace_isr_leave>
}
 8000c46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000c4a:	f001 bf49 	b.w	8002ae0 <__port_irq_epilogue>
 8000c4e:	bf00      	nop
 8000c50:	08002c70 	.word	0x08002c70
 8000c54:	24000390 	.word	0x24000390
	...

08000c60 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000c60:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8000c62:	4c06      	ldr	r4, [pc, #24]	; (8000c7c <VectorB0+0x1c>)
 8000c64:	4620      	mov	r0, r4
 8000c66:	f001 fd53 	bl	8002710 <__trace_isr_enter>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000c6a:	f001 fb31 	bl	80022d0 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000c6e:	4620      	mov	r0, r4
 8000c70:	f001 fd66 	bl	8002740 <__trace_isr_leave>
}
 8000c74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000c78:	f001 bf32 	b.w	8002ae0 <__port_irq_epilogue>
 8000c7c:	08002c64 	.word	0x08002c64

08000c80 <stm32_clock_init>:
 */
__STATIC_INLINE void rccEnableAPB4(uint32_t mask, bool lp) {

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->APB4ENR |= mask;
 8000c80:	4b66      	ldr	r3, [pc, #408]	; (8000e1c <stm32_clock_init+0x19c>)
  (void)pwr;
#endif

  /* Lower C3 byte, it must be programmed at very first, then waiting for
     power supply to stabilize.*/
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 8000c82:	2002      	movs	r0, #2

#if defined(STM32_ENFORCE_H7_REV_XY)
  /* Fix for errata 2.2.15: Reading from AXI SRAM might lead to data
     read corruption.
     AXI->TARG7_FN_MOD.*/
  *((volatile uint32_t *)(0x51000000 + 0x1108 + 0x7000)) = 0x00000001U;
 8000c84:	4966      	ldr	r1, [pc, #408]	; (8000e20 <stm32_clock_init+0x1a0>)
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 8000c86:	4a67      	ldr	r2, [pc, #412]	; (8000e24 <stm32_clock_init+0x1a4>)
void stm32_clock_init(void) {
 8000c88:	b410      	push	{r4}
  *((volatile uint32_t *)(0x51000000 + 0x1108 + 0x7000)) = 0x00000001U;
 8000c8a:	2401      	movs	r4, #1
 8000c8c:	f8c1 4108 	str.w	r4, [r1, #264]	; 0x108
 8000c90:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
 8000c94:	4301      	orrs	r1, r0
 8000c96:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
  if (lp) {
    RCC_C1->APB4LPENR |= mask;
 8000c9a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8000c9e:	4301      	orrs	r1, r0
 8000ca0:	f8c3 111c 	str.w	r1, [r3, #284]	; 0x11c
  }
  else {
    RCC_C1->APB4LPENR &= ~mask;
  }
  (void)RCC_C1->APB4LPENR;
 8000ca4:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 8000ca8:	60d0      	str	r0, [r2, #12]
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0)
 8000caa:	6853      	ldr	r3, [r2, #4]
 8000cac:	0499      	lsls	r1, r3, #18
 8000cae:	d5fc      	bpl.n	8000caa <stm32_clock_init+0x2a>
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
 8000cb0:	495d      	ldr	r1, [pc, #372]	; (8000e28 <stm32_clock_init+0x1a8>)
  PWR->CR2   = STM32_PWR_CR2;
 8000cb2:	2301      	movs	r3, #1
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 8000cb4:	4c5d      	ldr	r4, [pc, #372]	; (8000e2c <stm32_clock_init+0x1ac>)
  PWR->CPUCR = STM32_PWR_CPUCR;
 8000cb6:	2000      	movs	r0, #0
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
 8000cb8:	6011      	str	r1, [r2, #0]
  PWR->CR2   = STM32_PWR_CR2;
 8000cba:	6093      	str	r3, [r2, #8]
  PWR->D3CR  = STM32_VOS;
 8000cbc:	f44f 4340 	mov.w	r3, #49152	; 0xc000
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 8000cc0:	4958      	ldr	r1, [pc, #352]	; (8000e24 <stm32_clock_init+0x1a4>)
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 8000cc2:	60d4      	str	r4, [r2, #12]
  PWR->CPUCR = STM32_PWR_CPUCR;
 8000cc4:	6110      	str	r0, [r2, #16]
  PWR->D3CR  = STM32_VOS;
 8000cc6:	6193      	str	r3, [r2, #24]
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 8000cc8:	698b      	ldr	r3, [r1, #24]
 8000cca:	049b      	lsls	r3, r3, #18
 8000ccc:	d5fc      	bpl.n	8000cc8 <stm32_clock_init+0x48>
  PWR->CR1 |= PWR_CR1_DBP;
 8000cce:	680b      	ldr	r3, [r1, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8000cd0:	4a52      	ldr	r2, [pc, #328]	; (8000e1c <stm32_clock_init+0x19c>)
  PWR->CR1 |= PWR_CR1_DBP;
 8000cd2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000cd6:	600b      	str	r3, [r1, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8000cd8:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8000cda:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8000cde:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000ce2:	d004      	beq.n	8000cee <stm32_clock_init+0x6e>
    RCC->BDCR = RCC_BDCR_BDRST;
 8000ce4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    RCC->BDCR = 0;
 8000ce8:	2300      	movs	r3, #0
    RCC->BDCR = RCC_BDCR_BDRST;
 8000cea:	6711      	str	r1, [r2, #112]	; 0x70
    RCC->BDCR = 0;
 8000cec:	6713      	str	r3, [r2, #112]	; 0x70
  /* Backup domain initialization.*/
  init_bkp_domain();

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000cee:	494b      	ldr	r1, [pc, #300]	; (8000e1c <stm32_clock_init+0x19c>)
 8000cf0:	680b      	ldr	r3, [r1, #0]
 8000cf2:	f043 0301 	orr.w	r3, r3, #1
 8000cf6:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000cf8:	680b      	ldr	r3, [r1, #0]
 8000cfa:	075c      	lsls	r4, r3, #29
 8000cfc:	d5fc      	bpl.n	8000cf8 <stm32_clock_init+0x78>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. This is only required when using a debugger than can cause
     restarts.*/
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 8000cfe:	2300      	movs	r3, #0
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000d00:	4a46      	ldr	r2, [pc, #280]	; (8000e1c <stm32_clock_init+0x19c>)
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 8000d02:	610b      	str	r3, [r1, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000d04:	6913      	ldr	r3, [r2, #16]
 8000d06:	f013 0338 	ands.w	r3, r3, #56	; 0x38
 8000d0a:	d1fb      	bne.n	8000d04 <stm32_clock_init+0x84>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers cleared to reset values.*/
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 8000d0c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 8000d10:	2401      	movs	r4, #1
#if !defined(STM32_ENFORCE_H7_REV_XY)
  RCC->CSICFGR = 0x20000000U;              /* CSICFGR Reset value.         */
#endif
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 8000d12:	4947      	ldr	r1, [pc, #284]	; (8000e30 <stm32_clock_init+0x1b0>)
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 8000d14:	6014      	str	r4, [r2, #0]
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 8000d16:	6050      	str	r0, [r2, #4]
  cfgr |= STM32_HRTIMSEL;
#endif
#if STM32_TIMPRE_ENABLE == TRUE
  cfgr |= RCC_CFGR_TIMPRE;
#endif
  RCC->CFGR = cfgr;
 8000d18:	4846      	ldr	r0, [pc, #280]	; (8000e34 <stm32_clock_init+0x1b4>)
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
 8000d1a:	6753      	str	r3, [r2, #116]	; 0x74
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 8000d1c:	62d1      	str	r1, [r2, #44]	; 0x2c
  RCC->CFGR = cfgr;
 8000d1e:	6110      	str	r0, [r2, #16]

  /* HSE activation with optional bypass.*/
#if STM32_HSE_ENABLED == TRUE
#if defined(STM32_HSE_BYPASS)
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8000d20:	6813      	ldr	r3, [r2, #0]
#else
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8000d22:	493e      	ldr	r1, [pc, #248]	; (8000e1c <stm32_clock_init+0x19c>)
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8000d24:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 8000d28:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8000d2a:	680b      	ldr	r3, [r1, #0]
 8000d2c:	0398      	lsls	r0, r3, #14
 8000d2e:	d5fc      	bpl.n	8000d2a <stm32_clock_init+0xaa>
    ;                           /* Waits until HSE is stable.               */
#endif /* STM32_HSE_ENABLED == TRUE */

  /* HSI48 activation.*/
#if STM32_HSI48_ENABLED == TRUE
  RCC->CR |= RCC_CR_HSI48ON;
 8000d30:	680a      	ldr	r2, [r1, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 8000d32:	4b3a      	ldr	r3, [pc, #232]	; (8000e1c <stm32_clock_init+0x19c>)
  RCC->CR |= RCC_CR_HSI48ON;
 8000d34:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000d38:	600a      	str	r2, [r1, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 8000d3a:	681a      	ldr	r2, [r3, #0]
 8000d3c:	0492      	lsls	r2, r2, #18
 8000d3e:	d5fc      	bpl.n	8000d3a <stm32_clock_init+0xba>
    cfgmask = STM32_PLLCFGR_PLL3RGE | STM32_PLLCFGR_PLL3VCOSEL | RCC_PLLCFGR_PLL3FRACEN |
              STM32_PLLCFGR_PLL2RGE | STM32_PLLCFGR_PLL2VCOSEL | RCC_PLLCFGR_PLL2FRACEN |
              STM32_PLLCFGR_PLL1RGE | STM32_PLLCFGR_PLL1VCOSEL | RCC_PLLCFGR_PLL1FRACEN;

#if STM32_PLL1_ENABLED == TRUE
    RCC->PLL1FRACR = STM32_PLL1_FRACN;
 8000d40:	2200      	movs	r2, #0
    RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM3_VALUE(STM32_PLL3_DIVM_VALUE) |
 8000d42:	483d      	ldr	r0, [pc, #244]	; (8000e38 <stm32_clock_init+0x1b8>)
    RCC->PLL1DIVR  = STM32_PLL1_DIVR | STM32_PLL1_DIVQ |
 8000d44:	493d      	ldr	r1, [pc, #244]	; (8000e3c <stm32_clock_init+0x1bc>)
    cfgmask |= RCC_PLLCFGR_DIVR1EN;
#endif
#endif /* STM32_PLL1_ENABLED == TRUE */

#if STM32_PLL2_ENABLED == TRUE
    RCC->PLL2FRACR = STM32_PLL2_FRACN;
 8000d46:	f644 54f0 	movw	r4, #19952	; 0x4df0
    RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM3_VALUE(STM32_PLL3_DIVM_VALUE) |
 8000d4a:	6298      	str	r0, [r3, #40]	; 0x28
    RCC->PLL1FRACR = STM32_PLL1_FRACN;
 8000d4c:	635a      	str	r2, [r3, #52]	; 0x34
    RCC->PLL1DIVR  = STM32_PLL1_DIVR | STM32_PLL1_DIVQ |
 8000d4e:	6319      	str	r1, [r3, #48]	; 0x30
    RCC->PLL2DIVR  = STM32_PLL2_DIVR | STM32_PLL2_DIVQ |
 8000d50:	f5a1 21fe 	sub.w	r1, r1, #520192	; 0x7f000
    RCC->PLL2FRACR = STM32_PLL2_FRACN;
 8000d54:	63dc      	str	r4, [r3, #60]	; 0x3c
    RCC->PLL2DIVR  = STM32_PLL2_DIVR | STM32_PLL2_DIVQ |
 8000d56:	393e      	subs	r1, #62	; 0x3e
#endif
#endif /* STM32_PLL2_ENABLED == TRUE */

#if STM32_PLL3_ENABLED == TRUE
    RCC->PLL3FRACR = STM32_PLL3_FRACN;
    RCC->PLL3DIVR  = STM32_PLL3_DIVR | STM32_PLL3_DIVQ |
 8000d58:	4839      	ldr	r0, [pc, #228]	; (8000e40 <stm32_clock_init+0x1c0>)
    RCC->PLL2DIVR  = STM32_PLL2_DIVR | STM32_PLL2_DIVQ |
 8000d5a:	6399      	str	r1, [r3, #56]	; 0x38
    cfgmask |= RCC_PLLCFGR_DIVR3EN;
#endif
#endif /* STM32_PLL3_ENABLED == TRUE */

    /* Activating enabled PLLs and waiting for all of them to become ready.*/
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 8000d5c:	4939      	ldr	r1, [pc, #228]	; (8000e44 <stm32_clock_init+0x1c4>)
    RCC->PLL3FRACR = STM32_PLL3_FRACN;
 8000d5e:	645a      	str	r2, [r3, #68]	; 0x44
    RCC->PLL3DIVR  = STM32_PLL3_DIVR | STM32_PLL3_DIVQ |
 8000d60:	6418      	str	r0, [r3, #64]	; 0x40
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 8000d62:	62d9      	str	r1, [r3, #44]	; 0x2c
    RCC->CR     |= onmask;
 8000d64:	6819      	ldr	r1, [r3, #0]
    while ((RCC->CR & rdymask) != rdymask)
 8000d66:	4a2d      	ldr	r2, [pc, #180]	; (8000e1c <stm32_clock_init+0x19c>)
    RCC->CR     |= onmask;
 8000d68:	f041 51a8 	orr.w	r1, r1, #352321536	; 0x15000000
 8000d6c:	6019      	str	r1, [r3, #0]
    while ((RCC->CR & rdymask) != rdymask)
 8000d6e:	6813      	ldr	r3, [r2, #0]
 8000d70:	f003 5328 	and.w	r3, r3, #704643072	; 0x2a000000
 8000d74:	f1b3 5f28 	cmp.w	r3, #704643072	; 0x2a000000
 8000d78:	d1f9      	bne.n	8000d6e <stm32_clock_init+0xee>
#if defined(HAL_LLD_TYPE3_H)
  RCC->CDCFGR1 = STM32_CDCPRE  | STM32_CDPPRE | STM32_CDHPRE;
  RCC->CDCFGR2 = STM32_CDPPRE2 | STM32_CDPPRE1;
  RCC->SRDCFGR = STM32_SRDPPRE;
#else
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 8000d7a:	2448      	movs	r4, #72	; 0x48
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 8000d7c:	f44f 6388 	mov.w	r3, #1088	; 0x440
  RCC->D3CFGR = STM32_D3PPRE4;
 8000d80:	2040      	movs	r0, #64	; 0x40
#endif

  /* Peripherals clocks.*/
#if defined(HAL_LLD_TYPE1_H)
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_QSPISEL       |
 8000d82:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 8000d86:	6194      	str	r4, [r2, #24]
                  STM32_FMCSEL;
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
 8000d88:	f44f 5401 	mov.w	r4, #8256	; 0x2040
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 8000d8c:	61d3      	str	r3, [r2, #28]
                  STM32_SPDIFSEL   | STM32_SPDIFSEL    | STM32_SPI45SEL      |
                  STM32_SPI123SEL  | STM32_SAI23SEL    | STM32_SAI1SEL;
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8000d8e:	f44f 03e0 	mov.w	r3, #7340032	; 0x700000
  RCC->D3CFGR = STM32_D3PPRE4;
 8000d92:	6210      	str	r0, [r2, #32]
                  STM32_I2C123SEL  | STM32_RNGSEL      | STM32_USART16SEL    |
                  STM32_USART234578SEL;
  RCC->D3CCIPR  = STM32_SPI6SEL    | STM32_SAI4BSEL    | STM32_SAI4ASEL      |
 8000d94:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_QSPISEL       |
 8000d98:	64d1      	str	r1, [r2, #76]	; 0x4c
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
 8000d9a:	6514      	str	r4, [r2, #80]	; 0x50
                  STM32_LPTIM3SEL  | STM32_LPTIM2SEL   | STM32_I2C4SEL       |
                  STM32_LPUART1SEL;
#endif

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8000d9c:	492a      	ldr	r1, [pc, #168]	; (8000e48 <stm32_clock_init+0x1c8>)
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8000d9e:	6553      	str	r3, [r2, #84]	; 0x54
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8000da0:	2332      	movs	r3, #50	; 0x32
  RCC->D3CCIPR  = STM32_SPI6SEL    | STM32_SAI4BSEL    | STM32_SAI4ASEL      |
 8000da2:	6590      	str	r0, [r2, #88]	; 0x58
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8000da4:	600b      	str	r3, [r1, #0]
               STM32_FLASHBITS;
  while ((FLASH->ACR & FLASH_ACR_LATENCY) !=
 8000da6:	680b      	ldr	r3, [r1, #0]
 8000da8:	f003 030f 	and.w	r3, r3, #15
 8000dac:	2b02      	cmp	r3, #2
 8000dae:	d1fa      	bne.n	8000da6 <stm32_clock_init+0x126>
  }

  /* Switching to the configured clock source if it is different
     from HSI.*/
#if STM32_SW != STM32_SW_HSI_CK
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8000db0:	4a1a      	ldr	r2, [pc, #104]	; (8000e1c <stm32_clock_init+0x19c>)
 8000db2:	6913      	ldr	r3, [r2, #16]
 8000db4:	f043 0303 	orr.w	r3, r3, #3
 8000db8:	6113      	str	r3, [r2, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != (STM32_SW << RCC_CFGR_SWS_Pos))
 8000dba:	6913      	ldr	r3, [r2, #16]
 8000dbc:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8000dc0:	2b18      	cmp	r3, #24
 8000dc2:	d1fa      	bne.n	8000dba <stm32_clock_init+0x13a>
 */
__STATIC_INLINE void rccEnableAHB2(uint32_t mask, bool lp) {

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->AHB2ENR |= mask;
 8000dc4:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
  rccEnableSRAM2(true);
#if !(defined(HAL_LLD_TYPE2_H) || defined(HAL_LLD_TYPE3_H))
  rccEnableSRAM3(true);
#endif
#endif /* STM32_NO_INIT */
}
 8000dc8:	bc10      	pop	{r4}
 8000dca:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000dce:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
  if (lp) {
    RCC_C1->AHB2LPENR |= mask;
 8000dd2:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 8000dd6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000dda:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
  }
  else {
    RCC_C1->AHB2LPENR &= ~mask;
  }
  (void)RCC_C1->AHB2LPENR;
 8000dde:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
  RCC_C1->AHB2ENR |= mask;
 8000de2:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
 8000de6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000dea:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
    RCC_C1->AHB2LPENR |= mask;
 8000dee:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 8000df2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000df6:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
  (void)RCC_C1->AHB2LPENR;
 8000dfa:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
  RCC_C1->AHB2ENR |= mask;
 8000dfe:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
 8000e02:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000e06:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
    RCC_C1->AHB2LPENR |= mask;
 8000e0a:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 8000e0e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000e12:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
  (void)RCC_C1->AHB2LPENR;
 8000e16:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 8000e1a:	4770      	bx	lr
 8000e1c:	58024400 	.word	0x58024400
 8000e20:	51008000 	.word	0x51008000
 8000e24:	58024800 	.word	0x58024800
 8000e28:	f000c000 	.word	0xf000c000
 8000e2c:	01000002 	.word	0x01000002
 8000e30:	01ff0000 	.word	0x01ff0000
 8000e34:	08108800 	.word	0x08108800
 8000e38:	01905052 	.word	0x01905052
 8000e3c:	0109029f 	.word	0x0109029f
 8000e40:	0705071f 	.word	0x0705071f
 8000e44:	014b0399 	.word	0x014b0399
 8000e48:	52002000 	.word	0x52002000
 8000e4c:	00000000 	.word	0x00000000

08000e50 <adc_lld_stop_conversion>:
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

#if STM32_ADC_USE_ADC12 == TRUE
  if (&ADCD1 == adcp) {
 8000e50:	4b10      	ldr	r3, [pc, #64]	; (8000e94 <adc_lld_stop_conversion+0x44>)
 8000e52:	4298      	cmp	r0, r3
 8000e54:	d00d      	beq.n	8000e72 <adc_lld_stop_conversion+0x22>
    dmaStreamDisable(adcp->data.dma);
#endif
  }
#endif /* STM32_ADC_USE_ADC3 == TRUE */

  adc_lld_stop_adc(adcp);
 8000e56:	6a82      	ldr	r2, [r0, #40]	; 0x28
  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8000e58:	6893      	ldr	r3, [r2, #8]
 8000e5a:	0759      	lsls	r1, r3, #29
 8000e5c:	d506      	bpl.n	8000e6c <adc_lld_stop_conversion+0x1c>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8000e5e:	6893      	ldr	r3, [r2, #8]
 8000e60:	f043 0310 	orr.w	r3, r3, #16
 8000e64:	6093      	str	r3, [r2, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8000e66:	6893      	ldr	r3, [r2, #8]
 8000e68:	06db      	lsls	r3, r3, #27
 8000e6a:	d4fc      	bmi.n	8000e66 <adc_lld_stop_conversion+0x16>
  adcp->adcm->PCSEL = 0U;
 8000e6c:	2300      	movs	r3, #0
 8000e6e:	61d3      	str	r3, [r2, #28]
}
 8000e70:	4770      	bx	lr
    dmaStreamDisable(adcp->data.dma);
 8000e72:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8000e74:	680a      	ldr	r2, [r1, #0]
 8000e76:	6813      	ldr	r3, [r2, #0]
 8000e78:	f023 031f 	bic.w	r3, r3, #31
 8000e7c:	6013      	str	r3, [r2, #0]
 8000e7e:	6813      	ldr	r3, [r2, #0]
 8000e80:	07db      	lsls	r3, r3, #31
 8000e82:	d4fc      	bmi.n	8000e7e <adc_lld_stop_conversion+0x2e>
 8000e84:	f891 c00c 	ldrb.w	ip, [r1, #12]
 8000e88:	233d      	movs	r3, #61	; 0x3d
 8000e8a:	684a      	ldr	r2, [r1, #4]
 8000e8c:	fa03 f30c 	lsl.w	r3, r3, ip
 8000e90:	6013      	str	r3, [r2, #0]
 8000e92:	e7e0      	b.n	8000e56 <adc_lld_stop_conversion+0x6>
 8000e94:	24000000 	.word	0x24000000
	...

08000ea0 <Vector88>:
OSAL_IRQ_HANDLER(STM32_ADC12_HANDLER) {
 8000ea0:	b570      	push	{r4, r5, r6, lr}
  OSAL_IRQ_PROLOGUE();
 8000ea2:	4826      	ldr	r0, [pc, #152]	; (8000f3c <Vector88+0x9c>)
 8000ea4:	f001 fc34 	bl	8002710 <__trace_isr_enter>
  if (adcp->grpp != NULL) {
 8000ea8:	4d25      	ldr	r5, [pc, #148]	; (8000f40 <Vector88+0xa0>)
  isr  = ADC1->ISR;
 8000eaa:	4a26      	ldr	r2, [pc, #152]	; (8000f44 <Vector88+0xa4>)
  if (adcp->grpp != NULL) {
 8000eac:	692e      	ldr	r6, [r5, #16]
  isr  = ADC1->ISR;
 8000eae:	6813      	ldr	r3, [r2, #0]
  ADC1->ISR = isr;
 8000eb0:	6013      	str	r3, [r2, #0]
  if (adcp->grpp != NULL) {
 8000eb2:	b366      	cbz	r6, 8000f0e <Vector88+0x6e>
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8000eb4:	f013 0410 	ands.w	r4, r3, #16
 8000eb8:	d006      	beq.n	8000ec8 <Vector88+0x28>
 8000eba:	782c      	ldrb	r4, [r5, #0]
 8000ebc:	f1a4 0403 	sub.w	r4, r4, #3
 8000ec0:	fab4 f484 	clz	r4, r4
 8000ec4:	0964      	lsrs	r4, r4, #5
 8000ec6:	0064      	lsls	r4, r4, #1
    if (isr & ADC_ISR_AWD1) {
 8000ec8:	0618      	lsls	r0, r3, #24
      emask |= ADC_ERR_AWD1;
 8000eca:	bf48      	it	mi
 8000ecc:	f044 0404 	orrmi.w	r4, r4, #4
    if (isr & ADC_ISR_AWD2) {
 8000ed0:	05d9      	lsls	r1, r3, #23
 8000ed2:	d523      	bpl.n	8000f1c <Vector88+0x7c>
    if (isr & ADC_ISR_AWD3) {
 8000ed4:	059a      	lsls	r2, r3, #22
      emask |= ADC_ERR_AWD2;
 8000ed6:	f044 0408 	orr.w	r4, r4, #8
    if (isr & ADC_ISR_AWD3) {
 8000eda:	d501      	bpl.n	8000ee0 <Vector88+0x40>
      emask |= ADC_ERR_AWD3;
 8000edc:	f044 0410 	orr.w	r4, r4, #16
      _adc_isr_error_code(adcp, emask);
 8000ee0:	4817      	ldr	r0, [pc, #92]	; (8000f40 <Vector88+0xa0>)
 8000ee2:	f7ff ffb5 	bl	8000e50 <adc_lld_stop_conversion>
 8000ee6:	68f3      	ldr	r3, [r6, #12]
 8000ee8:	b31b      	cbz	r3, 8000f32 <Vector88+0x92>
 8000eea:	2205      	movs	r2, #5
 8000eec:	4621      	mov	r1, r4
 8000eee:	702a      	strb	r2, [r5, #0]
 8000ef0:	4798      	blx	r3
 8000ef2:	782b      	ldrb	r3, [r5, #0]
 8000ef4:	2b05      	cmp	r3, #5
 8000ef6:	d01c      	beq.n	8000f32 <Vector88+0x92>
 8000ef8:	2330      	movs	r3, #48	; 0x30
 8000efa:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 8000efe:	f04f 31ff 	mov.w	r1, #4294967295
 8000f02:	4811      	ldr	r0, [pc, #68]	; (8000f48 <Vector88+0xa8>)
 8000f04:	f001 fd8c 	bl	8002a20 <chThdResumeI>
 8000f08:	2300      	movs	r3, #0
 8000f0a:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8000f0e:	480b      	ldr	r0, [pc, #44]	; (8000f3c <Vector88+0x9c>)
 8000f10:	f001 fc16 	bl	8002740 <__trace_isr_leave>
}
 8000f14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8000f18:	f001 bde2 	b.w	8002ae0 <__port_irq_epilogue>
    if (isr & ADC_ISR_AWD3) {
 8000f1c:	059b      	lsls	r3, r3, #22
 8000f1e:	d4dd      	bmi.n	8000edc <Vector88+0x3c>
    if (emask != 0U) {
 8000f20:	2c00      	cmp	r4, #0
 8000f22:	d1dd      	bne.n	8000ee0 <Vector88+0x40>
  OSAL_IRQ_EPILOGUE();
 8000f24:	4805      	ldr	r0, [pc, #20]	; (8000f3c <Vector88+0x9c>)
 8000f26:	f001 fc0b 	bl	8002740 <__trace_isr_leave>
}
 8000f2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8000f2e:	f001 bdd7 	b.w	8002ae0 <__port_irq_epilogue>
      _adc_isr_error_code(adcp, emask);
 8000f32:	2202      	movs	r2, #2
 8000f34:	2300      	movs	r3, #0
 8000f36:	702a      	strb	r2, [r5, #0]
 8000f38:	612b      	str	r3, [r5, #16]
 8000f3a:	e7dd      	b.n	8000ef8 <Vector88+0x58>
 8000f3c:	08002c94 	.word	0x08002c94
 8000f40:	24000000 	.word	0x24000000
 8000f44:	40022000 	.word	0x40022000
 8000f48:	24000014 	.word	0x24000014
 8000f4c:	00000000 	.word	0x00000000

08000f50 <Vector244>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8000f50:	480a      	ldr	r0, [pc, #40]	; (8000f7c <Vector244+0x2c>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH0_HANDLER) {
 8000f52:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8000f54:	f001 fbdc 	bl	8002710 <__trace_isr_enter>

  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 8000f58:	4b09      	ldr	r3, [pc, #36]	; (8000f80 <Vector244+0x30>)
  BDMA->IFCR = flags << 0U;
  if (bdma.streams[0].func)
 8000f5a:	480a      	ldr	r0, [pc, #40]	; (8000f84 <Vector244+0x34>)
  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 8000f5c:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[0].func)
 8000f5e:	6842      	ldr	r2, [r0, #4]
  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 8000f60:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 0U;
 8000f64:	6059      	str	r1, [r3, #4]
  if (bdma.streams[0].func)
 8000f66:	b10a      	cbz	r2, 8000f6c <Vector244+0x1c>
    bdma.streams[0].func(bdma.streams[0].param, flags);
 8000f68:	6880      	ldr	r0, [r0, #8]
 8000f6a:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8000f6c:	4803      	ldr	r0, [pc, #12]	; (8000f7c <Vector244+0x2c>)
 8000f6e:	f001 fbe7 	bl	8002740 <__trace_isr_leave>
}
 8000f72:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000f76:	f001 bdb3 	b.w	8002ae0 <__port_irq_epilogue>
 8000f7a:	bf00      	nop
 8000f7c:	08002cf4 	.word	0x08002cf4
 8000f80:	58025400 	.word	0x58025400
 8000f84:	24000038 	.word	0x24000038
	...

08000f90 <Vector248>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8000f90:	480b      	ldr	r0, [pc, #44]	; (8000fc0 <Vector248+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH1_HANDLER) {
 8000f92:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8000f94:	f001 fbbc 	bl	8002710 <__trace_isr_enter>

  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 8000f98:	4b0a      	ldr	r3, [pc, #40]	; (8000fc4 <Vector248+0x34>)
  BDMA->IFCR = flags << 4U;
  if (bdma.streams[1].func)
 8000f9a:	480b      	ldr	r0, [pc, #44]	; (8000fc8 <Vector248+0x38>)
  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 8000f9c:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[1].func)
 8000f9e:	68c2      	ldr	r2, [r0, #12]
  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 8000fa0:	0909      	lsrs	r1, r1, #4
 8000fa2:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 4U;
 8000fa6:	010c      	lsls	r4, r1, #4
 8000fa8:	605c      	str	r4, [r3, #4]
  if (bdma.streams[1].func)
 8000faa:	b10a      	cbz	r2, 8000fb0 <Vector248+0x20>
    bdma.streams[1].func(bdma.streams[1].param, flags);
 8000fac:	6900      	ldr	r0, [r0, #16]
 8000fae:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8000fb0:	4803      	ldr	r0, [pc, #12]	; (8000fc0 <Vector248+0x30>)
 8000fb2:	f001 fbc5 	bl	8002740 <__trace_isr_leave>
}
 8000fb6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000fba:	f001 bd91 	b.w	8002ae0 <__port_irq_epilogue>
 8000fbe:	bf00      	nop
 8000fc0:	08002ce8 	.word	0x08002ce8
 8000fc4:	58025400 	.word	0x58025400
 8000fc8:	24000038 	.word	0x24000038
 8000fcc:	00000000 	.word	0x00000000

08000fd0 <Vector24C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8000fd0:	480b      	ldr	r0, [pc, #44]	; (8001000 <Vector24C+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH2_HANDLER) {
 8000fd2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8000fd4:	f001 fb9c 	bl	8002710 <__trace_isr_enter>

  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 8000fd8:	4b0a      	ldr	r3, [pc, #40]	; (8001004 <Vector24C+0x34>)
  BDMA->IFCR = flags << 8U;
  if (bdma.streams[2].func)
 8000fda:	480b      	ldr	r0, [pc, #44]	; (8001008 <Vector24C+0x38>)
  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 8000fdc:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[2].func)
 8000fde:	6942      	ldr	r2, [r0, #20]
  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 8000fe0:	0a09      	lsrs	r1, r1, #8
 8000fe2:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 8U;
 8000fe6:	020c      	lsls	r4, r1, #8
 8000fe8:	605c      	str	r4, [r3, #4]
  if (bdma.streams[2].func)
 8000fea:	b10a      	cbz	r2, 8000ff0 <Vector24C+0x20>
    bdma.streams[2].func(bdma.streams[2].param, flags);
 8000fec:	6980      	ldr	r0, [r0, #24]
 8000fee:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8000ff0:	4803      	ldr	r0, [pc, #12]	; (8001000 <Vector24C+0x30>)
 8000ff2:	f001 fba5 	bl	8002740 <__trace_isr_leave>
}
 8000ff6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000ffa:	f001 bd71 	b.w	8002ae0 <__port_irq_epilogue>
 8000ffe:	bf00      	nop
 8001000:	08002cdc 	.word	0x08002cdc
 8001004:	58025400 	.word	0x58025400
 8001008:	24000038 	.word	0x24000038
 800100c:	00000000 	.word	0x00000000

08001010 <Vector250>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001010:	480b      	ldr	r0, [pc, #44]	; (8001040 <Vector250+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH3_HANDLER) {
 8001012:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001014:	f001 fb7c 	bl	8002710 <__trace_isr_enter>

  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 8001018:	4b0a      	ldr	r3, [pc, #40]	; (8001044 <Vector250+0x34>)
  BDMA->IFCR = flags << 12U;
  if (bdma.streams[3].func)
 800101a:	480b      	ldr	r0, [pc, #44]	; (8001048 <Vector250+0x38>)
  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 800101c:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[3].func)
 800101e:	69c2      	ldr	r2, [r0, #28]
  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 8001020:	0b09      	lsrs	r1, r1, #12
 8001022:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 12U;
 8001026:	030c      	lsls	r4, r1, #12
 8001028:	605c      	str	r4, [r3, #4]
  if (bdma.streams[3].func)
 800102a:	b10a      	cbz	r2, 8001030 <Vector250+0x20>
    bdma.streams[3].func(bdma.streams[3].param, flags);
 800102c:	6a00      	ldr	r0, [r0, #32]
 800102e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001030:	4803      	ldr	r0, [pc, #12]	; (8001040 <Vector250+0x30>)
 8001032:	f001 fb85 	bl	8002740 <__trace_isr_leave>
}
 8001036:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800103a:	f001 bd51 	b.w	8002ae0 <__port_irq_epilogue>
 800103e:	bf00      	nop
 8001040:	08002cd0 	.word	0x08002cd0
 8001044:	58025400 	.word	0x58025400
 8001048:	24000038 	.word	0x24000038
 800104c:	00000000 	.word	0x00000000

08001050 <Vector254>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001050:	480b      	ldr	r0, [pc, #44]	; (8001080 <Vector254+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH4_HANDLER) {
 8001052:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001054:	f001 fb5c 	bl	8002710 <__trace_isr_enter>

  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 8001058:	4b0a      	ldr	r3, [pc, #40]	; (8001084 <Vector254+0x34>)
  BDMA->IFCR = flags << 16U;
  if (bdma.streams[4].func)
 800105a:	480b      	ldr	r0, [pc, #44]	; (8001088 <Vector254+0x38>)
  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 800105c:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[4].func)
 800105e:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 8001060:	0c09      	lsrs	r1, r1, #16
 8001062:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 16U;
 8001066:	040c      	lsls	r4, r1, #16
 8001068:	605c      	str	r4, [r3, #4]
  if (bdma.streams[4].func)
 800106a:	b10a      	cbz	r2, 8001070 <Vector254+0x20>
    bdma.streams[4].func(bdma.streams[4].param, flags);
 800106c:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800106e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001070:	4803      	ldr	r0, [pc, #12]	; (8001080 <Vector254+0x30>)
 8001072:	f001 fb65 	bl	8002740 <__trace_isr_leave>
}
 8001076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800107a:	f001 bd31 	b.w	8002ae0 <__port_irq_epilogue>
 800107e:	bf00      	nop
 8001080:	08002cc4 	.word	0x08002cc4
 8001084:	58025400 	.word	0x58025400
 8001088:	24000038 	.word	0x24000038
 800108c:	00000000 	.word	0x00000000

08001090 <Vector258>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001090:	480b      	ldr	r0, [pc, #44]	; (80010c0 <Vector258+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH5_HANDLER) {
 8001092:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001094:	f001 fb3c 	bl	8002710 <__trace_isr_enter>

  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 8001098:	4b0a      	ldr	r3, [pc, #40]	; (80010c4 <Vector258+0x34>)
  BDMA->IFCR = flags << 20U;
  if (bdma.streams[5].func)
 800109a:	480b      	ldr	r0, [pc, #44]	; (80010c8 <Vector258+0x38>)
  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 800109c:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[5].func)
 800109e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 80010a0:	0d09      	lsrs	r1, r1, #20
 80010a2:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 20U;
 80010a6:	050c      	lsls	r4, r1, #20
 80010a8:	605c      	str	r4, [r3, #4]
  if (bdma.streams[5].func)
 80010aa:	b10a      	cbz	r2, 80010b0 <Vector258+0x20>
    bdma.streams[5].func(bdma.streams[5].param, flags);
 80010ac:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80010ae:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80010b0:	4803      	ldr	r0, [pc, #12]	; (80010c0 <Vector258+0x30>)
 80010b2:	f001 fb45 	bl	8002740 <__trace_isr_leave>
}
 80010b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80010ba:	f001 bd11 	b.w	8002ae0 <__port_irq_epilogue>
 80010be:	bf00      	nop
 80010c0:	08002cb8 	.word	0x08002cb8
 80010c4:	58025400 	.word	0x58025400
 80010c8:	24000038 	.word	0x24000038
 80010cc:	00000000 	.word	0x00000000

080010d0 <Vector25C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80010d0:	480b      	ldr	r0, [pc, #44]	; (8001100 <Vector25C+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH6_HANDLER) {
 80010d2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80010d4:	f001 fb1c 	bl	8002710 <__trace_isr_enter>

  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 80010d8:	4b0a      	ldr	r3, [pc, #40]	; (8001104 <Vector25C+0x34>)
  BDMA->IFCR = flags << 24U;
  if (bdma.streams[6].func)
 80010da:	480b      	ldr	r0, [pc, #44]	; (8001108 <Vector25C+0x38>)
  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 80010dc:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[6].func)
 80010de:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 80010e0:	0e09      	lsrs	r1, r1, #24
 80010e2:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 24U;
 80010e6:	060c      	lsls	r4, r1, #24
 80010e8:	605c      	str	r4, [r3, #4]
  if (bdma.streams[6].func)
 80010ea:	b10a      	cbz	r2, 80010f0 <Vector25C+0x20>
    bdma.streams[6].func(bdma.streams[6].param, flags);
 80010ec:	6b80      	ldr	r0, [r0, #56]	; 0x38
 80010ee:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80010f0:	4803      	ldr	r0, [pc, #12]	; (8001100 <Vector25C+0x30>)
 80010f2:	f001 fb25 	bl	8002740 <__trace_isr_leave>
}
 80010f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80010fa:	f001 bcf1 	b.w	8002ae0 <__port_irq_epilogue>
 80010fe:	bf00      	nop
 8001100:	08002cac 	.word	0x08002cac
 8001104:	58025400 	.word	0x58025400
 8001108:	24000038 	.word	0x24000038
 800110c:	00000000 	.word	0x00000000

08001110 <Vector260>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001110:	480b      	ldr	r0, [pc, #44]	; (8001140 <Vector260+0x30>)
OSAL_IRQ_HANDLER(STM32_BDMA1_CH7_HANDLER) {
 8001112:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001114:	f001 fafc 	bl	8002710 <__trace_isr_enter>

  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 8001118:	4b0a      	ldr	r3, [pc, #40]	; (8001144 <Vector260+0x34>)
  BDMA->IFCR = flags << 28U;
  if (bdma.streams[7].func)
 800111a:	480b      	ldr	r0, [pc, #44]	; (8001148 <Vector260+0x38>)
  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 800111c:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[7].func)
 800111e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 8001120:	0f09      	lsrs	r1, r1, #28
 8001122:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 28U;
 8001126:	070c      	lsls	r4, r1, #28
 8001128:	605c      	str	r4, [r3, #4]
  if (bdma.streams[7].func)
 800112a:	b10a      	cbz	r2, 8001130 <Vector260+0x20>
    bdma.streams[7].func(bdma.streams[7].param, flags);
 800112c:	6c00      	ldr	r0, [r0, #64]	; 0x40
 800112e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001130:	4803      	ldr	r0, [pc, #12]	; (8001140 <Vector260+0x30>)
 8001132:	f001 fb05 	bl	8002740 <__trace_isr_leave>
}
 8001136:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800113a:	f001 bcd1 	b.w	8002ae0 <__port_irq_epilogue>
 800113e:	bf00      	nop
 8001140:	08002ca0 	.word	0x08002ca0
 8001144:	58025400 	.word	0x58025400
 8001148:	24000038 	.word	0x24000038
 800114c:	00000000 	.word	0x00000000

08001150 <Vector6C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001150:	480a      	ldr	r0, [pc, #40]	; (800117c <Vector6C+0x2c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8001152:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001154:	f001 fadc 	bl	8002710 <__trace_isr_enter>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8001158:	4b09      	ldr	r3, [pc, #36]	; (8001180 <Vector6C+0x30>)
  DMA1->LIFCR = flags << 0U;
  if (dma.streams[0].func)
 800115a:	480a      	ldr	r0, [pc, #40]	; (8001184 <Vector6C+0x34>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800115c:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
 800115e:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8001160:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8001164:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8001166:	b10a      	cbz	r2, 800116c <Vector6C+0x1c>
    dma.streams[0].func(dma.streams[0].param, flags);
 8001168:	6880      	ldr	r0, [r0, #8]
 800116a:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800116c:	4803      	ldr	r0, [pc, #12]	; (800117c <Vector6C+0x2c>)
 800116e:	f001 fae7 	bl	8002740 <__trace_isr_leave>
}
 8001172:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001176:	f001 bcb3 	b.w	8002ae0 <__port_irq_epilogue>
 800117a:	bf00      	nop
 800117c:	08002d54 	.word	0x08002d54
 8001180:	40020000 	.word	0x40020000
 8001184:	2400007c 	.word	0x2400007c
	...

08001190 <Vector70>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001190:	480b      	ldr	r0, [pc, #44]	; (80011c0 <Vector70+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001192:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001194:	f001 fabc 	bl	8002710 <__trace_isr_enter>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001198:	4b0a      	ldr	r3, [pc, #40]	; (80011c4 <Vector70+0x34>)
  DMA1->LIFCR = flags << 6U;
  if (dma.streams[1].func)
 800119a:	480b      	ldr	r0, [pc, #44]	; (80011c8 <Vector70+0x38>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800119c:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[1].func)
 800119e:	68c2      	ldr	r2, [r0, #12]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80011a0:	0989      	lsrs	r1, r1, #6
 80011a2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 80011a6:	018c      	lsls	r4, r1, #6
 80011a8:	609c      	str	r4, [r3, #8]
  if (dma.streams[1].func)
 80011aa:	b10a      	cbz	r2, 80011b0 <Vector70+0x20>
    dma.streams[1].func(dma.streams[1].param, flags);
 80011ac:	6900      	ldr	r0, [r0, #16]
 80011ae:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80011b0:	4803      	ldr	r0, [pc, #12]	; (80011c0 <Vector70+0x30>)
 80011b2:	f001 fac5 	bl	8002740 <__trace_isr_leave>
}
 80011b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80011ba:	f001 bc91 	b.w	8002ae0 <__port_irq_epilogue>
 80011be:	bf00      	nop
 80011c0:	08002d48 	.word	0x08002d48
 80011c4:	40020000 	.word	0x40020000
 80011c8:	2400007c 	.word	0x2400007c
 80011cc:	00000000 	.word	0x00000000

080011d0 <Vector74>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80011d0:	480b      	ldr	r0, [pc, #44]	; (8001200 <Vector74+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80011d2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80011d4:	f001 fa9c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80011d8:	4b0a      	ldr	r3, [pc, #40]	; (8001204 <Vector74+0x34>)
  DMA1->LIFCR = flags << 16U;
  if (dma.streams[2].func)
 80011da:	480b      	ldr	r0, [pc, #44]	; (8001208 <Vector74+0x38>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80011dc:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[2].func)
 80011de:	6942      	ldr	r2, [r0, #20]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80011e0:	0c09      	lsrs	r1, r1, #16
 80011e2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 80011e6:	040c      	lsls	r4, r1, #16
 80011e8:	609c      	str	r4, [r3, #8]
  if (dma.streams[2].func)
 80011ea:	b10a      	cbz	r2, 80011f0 <Vector74+0x20>
    dma.streams[2].func(dma.streams[2].param, flags);
 80011ec:	6980      	ldr	r0, [r0, #24]
 80011ee:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80011f0:	4803      	ldr	r0, [pc, #12]	; (8001200 <Vector74+0x30>)
 80011f2:	f001 faa5 	bl	8002740 <__trace_isr_leave>
}
 80011f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80011fa:	f001 bc71 	b.w	8002ae0 <__port_irq_epilogue>
 80011fe:	bf00      	nop
 8001200:	08002d3c 	.word	0x08002d3c
 8001204:	40020000 	.word	0x40020000
 8001208:	2400007c 	.word	0x2400007c
 800120c:	00000000 	.word	0x00000000

08001210 <Vector78>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001210:	480b      	ldr	r0, [pc, #44]	; (8001240 <Vector78+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8001212:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001214:	f001 fa7c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001218:	4b0a      	ldr	r3, [pc, #40]	; (8001244 <Vector78+0x34>)
  DMA1->LIFCR = flags << 22U;
  if (dma.streams[3].func)
 800121a:	480b      	ldr	r0, [pc, #44]	; (8001248 <Vector78+0x38>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800121c:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[3].func)
 800121e:	69c2      	ldr	r2, [r0, #28]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001220:	0d89      	lsrs	r1, r1, #22
 8001222:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 8001226:	058c      	lsls	r4, r1, #22
 8001228:	609c      	str	r4, [r3, #8]
  if (dma.streams[3].func)
 800122a:	b10a      	cbz	r2, 8001230 <Vector78+0x20>
    dma.streams[3].func(dma.streams[3].param, flags);
 800122c:	6a00      	ldr	r0, [r0, #32]
 800122e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001230:	4803      	ldr	r0, [pc, #12]	; (8001240 <Vector78+0x30>)
 8001232:	f001 fa85 	bl	8002740 <__trace_isr_leave>
}
 8001236:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800123a:	f001 bc51 	b.w	8002ae0 <__port_irq_epilogue>
 800123e:	bf00      	nop
 8001240:	08002d30 	.word	0x08002d30
 8001244:	40020000 	.word	0x40020000
 8001248:	2400007c 	.word	0x2400007c
 800124c:	00000000 	.word	0x00000000

08001250 <Vector7C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001250:	480a      	ldr	r0, [pc, #40]	; (800127c <Vector7C+0x2c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001252:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001254:	f001 fa5c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001258:	4b09      	ldr	r3, [pc, #36]	; (8001280 <Vector7C+0x30>)
  DMA1->HIFCR = flags << 0U;
  if (dma.streams[4].func)
 800125a:	480a      	ldr	r0, [pc, #40]	; (8001284 <Vector7C+0x34>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800125c:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
 800125e:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001260:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8001264:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 8001266:	b10a      	cbz	r2, 800126c <Vector7C+0x1c>
    dma.streams[4].func(dma.streams[4].param, flags);
 8001268:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800126a:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800126c:	4803      	ldr	r0, [pc, #12]	; (800127c <Vector7C+0x2c>)
 800126e:	f001 fa67 	bl	8002740 <__trace_isr_leave>
}
 8001272:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001276:	f001 bc33 	b.w	8002ae0 <__port_irq_epilogue>
 800127a:	bf00      	nop
 800127c:	08002d24 	.word	0x08002d24
 8001280:	40020000 	.word	0x40020000
 8001284:	2400007c 	.word	0x2400007c
	...

08001290 <Vector80>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001290:	480b      	ldr	r0, [pc, #44]	; (80012c0 <Vector80+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8001292:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001294:	f001 fa3c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001298:	4b0a      	ldr	r3, [pc, #40]	; (80012c4 <Vector80+0x34>)
  DMA1->HIFCR = flags << 6U;
  if (dma.streams[5].func)
 800129a:	480b      	ldr	r0, [pc, #44]	; (80012c8 <Vector80+0x38>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800129c:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[5].func)
 800129e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80012a0:	0989      	lsrs	r1, r1, #6
 80012a2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 80012a6:	018c      	lsls	r4, r1, #6
 80012a8:	60dc      	str	r4, [r3, #12]
  if (dma.streams[5].func)
 80012aa:	b10a      	cbz	r2, 80012b0 <Vector80+0x20>
    dma.streams[5].func(dma.streams[5].param, flags);
 80012ac:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80012ae:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80012b0:	4803      	ldr	r0, [pc, #12]	; (80012c0 <Vector80+0x30>)
 80012b2:	f001 fa45 	bl	8002740 <__trace_isr_leave>
}
 80012b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80012ba:	f001 bc11 	b.w	8002ae0 <__port_irq_epilogue>
 80012be:	bf00      	nop
 80012c0:	08002d18 	.word	0x08002d18
 80012c4:	40020000 	.word	0x40020000
 80012c8:	2400007c 	.word	0x2400007c
 80012cc:	00000000 	.word	0x00000000

080012d0 <Vector84>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80012d0:	480b      	ldr	r0, [pc, #44]	; (8001300 <Vector84+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80012d2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80012d4:	f001 fa1c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80012d8:	4b0a      	ldr	r3, [pc, #40]	; (8001304 <Vector84+0x34>)
  DMA1->HIFCR = flags << 16U;
  if (dma.streams[6].func)
 80012da:	480b      	ldr	r0, [pc, #44]	; (8001308 <Vector84+0x38>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80012dc:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[6].func)
 80012de:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80012e0:	0c09      	lsrs	r1, r1, #16
 80012e2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 80012e6:	040c      	lsls	r4, r1, #16
 80012e8:	60dc      	str	r4, [r3, #12]
  if (dma.streams[6].func)
 80012ea:	b10a      	cbz	r2, 80012f0 <Vector84+0x20>
    dma.streams[6].func(dma.streams[6].param, flags);
 80012ec:	6b80      	ldr	r0, [r0, #56]	; 0x38
 80012ee:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80012f0:	4803      	ldr	r0, [pc, #12]	; (8001300 <Vector84+0x30>)
 80012f2:	f001 fa25 	bl	8002740 <__trace_isr_leave>
}
 80012f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80012fa:	f001 bbf1 	b.w	8002ae0 <__port_irq_epilogue>
 80012fe:	bf00      	nop
 8001300:	08002db4 	.word	0x08002db4
 8001304:	40020000 	.word	0x40020000
 8001308:	2400007c 	.word	0x2400007c
 800130c:	00000000 	.word	0x00000000

08001310 <VectorFC>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001310:	480b      	ldr	r0, [pc, #44]	; (8001340 <VectorFC+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8001312:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001314:	f001 f9fc 	bl	8002710 <__trace_isr_enter>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001318:	4b0a      	ldr	r3, [pc, #40]	; (8001344 <VectorFC+0x34>)
  DMA1->HIFCR = flags << 22U;
  if (dma.streams[7].func)
 800131a:	480b      	ldr	r0, [pc, #44]	; (8001348 <VectorFC+0x38>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800131c:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[7].func)
 800131e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001320:	0d89      	lsrs	r1, r1, #22
 8001322:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 8001326:	058c      	lsls	r4, r1, #22
 8001328:	60dc      	str	r4, [r3, #12]
  if (dma.streams[7].func)
 800132a:	b10a      	cbz	r2, 8001330 <VectorFC+0x20>
    dma.streams[7].func(dma.streams[7].param, flags);
 800132c:	6c00      	ldr	r0, [r0, #64]	; 0x40
 800132e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001330:	4803      	ldr	r0, [pc, #12]	; (8001340 <VectorFC+0x30>)
 8001332:	f001 fa05 	bl	8002740 <__trace_isr_leave>
}
 8001336:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800133a:	f001 bbd1 	b.w	8002ae0 <__port_irq_epilogue>
 800133e:	bf00      	nop
 8001340:	08002da8 	.word	0x08002da8
 8001344:	40020000 	.word	0x40020000
 8001348:	2400007c 	.word	0x2400007c
 800134c:	00000000 	.word	0x00000000

08001350 <Vector120>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001350:	480a      	ldr	r0, [pc, #40]	; (800137c <Vector120+0x2c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8001352:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001354:	f001 f9dc 	bl	8002710 <__trace_isr_enter>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8001358:	4b09      	ldr	r3, [pc, #36]	; (8001380 <Vector120+0x30>)
  DMA2->LIFCR = flags << 0U;
  if (dma.streams[8].func)
 800135a:	480a      	ldr	r0, [pc, #40]	; (8001384 <Vector120+0x34>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800135c:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
 800135e:	6c42      	ldr	r2, [r0, #68]	; 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8001360:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8001364:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 8001366:	b10a      	cbz	r2, 800136c <Vector120+0x1c>
    dma.streams[8].func(dma.streams[8].param, flags);
 8001368:	6c80      	ldr	r0, [r0, #72]	; 0x48
 800136a:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800136c:	4803      	ldr	r0, [pc, #12]	; (800137c <Vector120+0x2c>)
 800136e:	f001 f9e7 	bl	8002740 <__trace_isr_leave>
}
 8001372:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001376:	f001 bbb3 	b.w	8002ae0 <__port_irq_epilogue>
 800137a:	bf00      	nop
 800137c:	08002d9c 	.word	0x08002d9c
 8001380:	40020400 	.word	0x40020400
 8001384:	2400007c 	.word	0x2400007c
	...

08001390 <Vector124>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001390:	480b      	ldr	r0, [pc, #44]	; (80013c0 <Vector124+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8001392:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001394:	f001 f9bc 	bl	8002710 <__trace_isr_enter>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001398:	4b0a      	ldr	r3, [pc, #40]	; (80013c4 <Vector124+0x34>)
  DMA2->LIFCR = flags << 6U;
  if (dma.streams[9].func)
 800139a:	480b      	ldr	r0, [pc, #44]	; (80013c8 <Vector124+0x38>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800139c:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[9].func)
 800139e:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80013a0:	0989      	lsrs	r1, r1, #6
 80013a2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 80013a6:	018c      	lsls	r4, r1, #6
 80013a8:	609c      	str	r4, [r3, #8]
  if (dma.streams[9].func)
 80013aa:	b10a      	cbz	r2, 80013b0 <Vector124+0x20>
    dma.streams[9].func(dma.streams[9].param, flags);
 80013ac:	6d00      	ldr	r0, [r0, #80]	; 0x50
 80013ae:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80013b0:	4803      	ldr	r0, [pc, #12]	; (80013c0 <Vector124+0x30>)
 80013b2:	f001 f9c5 	bl	8002740 <__trace_isr_leave>
}
 80013b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80013ba:	f001 bb91 	b.w	8002ae0 <__port_irq_epilogue>
 80013be:	bf00      	nop
 80013c0:	08002d90 	.word	0x08002d90
 80013c4:	40020400 	.word	0x40020400
 80013c8:	2400007c 	.word	0x2400007c
 80013cc:	00000000 	.word	0x00000000

080013d0 <Vector128>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80013d0:	480b      	ldr	r0, [pc, #44]	; (8001400 <Vector128+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80013d2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80013d4:	f001 f99c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80013d8:	4b0a      	ldr	r3, [pc, #40]	; (8001404 <Vector128+0x34>)
  DMA2->LIFCR = flags << 16U;
  if (dma.streams[10].func)
 80013da:	480b      	ldr	r0, [pc, #44]	; (8001408 <Vector128+0x38>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80013dc:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[10].func)
 80013de:	6d42      	ldr	r2, [r0, #84]	; 0x54
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80013e0:	0c09      	lsrs	r1, r1, #16
 80013e2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 80013e6:	040c      	lsls	r4, r1, #16
 80013e8:	609c      	str	r4, [r3, #8]
  if (dma.streams[10].func)
 80013ea:	b10a      	cbz	r2, 80013f0 <Vector128+0x20>
    dma.streams[10].func(dma.streams[10].param, flags);
 80013ec:	6d80      	ldr	r0, [r0, #88]	; 0x58
 80013ee:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80013f0:	4803      	ldr	r0, [pc, #12]	; (8001400 <Vector128+0x30>)
 80013f2:	f001 f9a5 	bl	8002740 <__trace_isr_leave>
}
 80013f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80013fa:	f001 bb71 	b.w	8002ae0 <__port_irq_epilogue>
 80013fe:	bf00      	nop
 8001400:	08002d84 	.word	0x08002d84
 8001404:	40020400 	.word	0x40020400
 8001408:	2400007c 	.word	0x2400007c
 800140c:	00000000 	.word	0x00000000

08001410 <Vector12C>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001410:	480b      	ldr	r0, [pc, #44]	; (8001440 <Vector12C+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8001412:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001414:	f001 f97c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001418:	4b0a      	ldr	r3, [pc, #40]	; (8001444 <Vector12C+0x34>)
  DMA2->LIFCR = flags << 22U;
  if (dma.streams[11].func)
 800141a:	480b      	ldr	r0, [pc, #44]	; (8001448 <Vector12C+0x38>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800141c:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[11].func)
 800141e:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001420:	0d89      	lsrs	r1, r1, #22
 8001422:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 8001426:	058c      	lsls	r4, r1, #22
 8001428:	609c      	str	r4, [r3, #8]
  if (dma.streams[11].func)
 800142a:	b10a      	cbz	r2, 8001430 <Vector12C+0x20>
    dma.streams[11].func(dma.streams[11].param, flags);
 800142c:	6e00      	ldr	r0, [r0, #96]	; 0x60
 800142e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001430:	4803      	ldr	r0, [pc, #12]	; (8001440 <Vector12C+0x30>)
 8001432:	f001 f985 	bl	8002740 <__trace_isr_leave>
}
 8001436:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800143a:	f001 bb51 	b.w	8002ae0 <__port_irq_epilogue>
 800143e:	bf00      	nop
 8001440:	08002d78 	.word	0x08002d78
 8001444:	40020400 	.word	0x40020400
 8001448:	2400007c 	.word	0x2400007c
 800144c:	00000000 	.word	0x00000000

08001450 <Vector130>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001450:	480a      	ldr	r0, [pc, #40]	; (800147c <Vector130+0x2c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001452:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8001454:	f001 f95c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001458:	4b09      	ldr	r3, [pc, #36]	; (8001480 <Vector130+0x30>)
  DMA2->HIFCR = flags << 0U;
  if (dma.streams[12].func)
 800145a:	480a      	ldr	r0, [pc, #40]	; (8001484 <Vector130+0x34>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800145c:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
 800145e:	6e42      	ldr	r2, [r0, #100]	; 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001460:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8001464:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 8001466:	b10a      	cbz	r2, 800146c <Vector130+0x1c>
    dma.streams[12].func(dma.streams[12].param, flags);
 8001468:	6e80      	ldr	r0, [r0, #104]	; 0x68
 800146a:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800146c:	4803      	ldr	r0, [pc, #12]	; (800147c <Vector130+0x2c>)
 800146e:	f001 f967 	bl	8002740 <__trace_isr_leave>
}
 8001472:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001476:	f001 bb33 	b.w	8002ae0 <__port_irq_epilogue>
 800147a:	bf00      	nop
 800147c:	08002d6c 	.word	0x08002d6c
 8001480:	40020400 	.word	0x40020400
 8001484:	2400007c 	.word	0x2400007c
	...

08001490 <Vector150>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001490:	480b      	ldr	r0, [pc, #44]	; (80014c0 <Vector150+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001492:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001494:	f001 f93c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001498:	4b0a      	ldr	r3, [pc, #40]	; (80014c4 <Vector150+0x34>)
  DMA2->HIFCR = flags << 6U;
  if (dma.streams[13].func)
 800149a:	480b      	ldr	r0, [pc, #44]	; (80014c8 <Vector150+0x38>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800149c:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[13].func)
 800149e:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80014a0:	0989      	lsrs	r1, r1, #6
 80014a2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 80014a6:	018c      	lsls	r4, r1, #6
 80014a8:	60dc      	str	r4, [r3, #12]
  if (dma.streams[13].func)
 80014aa:	b10a      	cbz	r2, 80014b0 <Vector150+0x20>
    dma.streams[13].func(dma.streams[13].param, flags);
 80014ac:	6f00      	ldr	r0, [r0, #112]	; 0x70
 80014ae:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80014b0:	4803      	ldr	r0, [pc, #12]	; (80014c0 <Vector150+0x30>)
 80014b2:	f001 f945 	bl	8002740 <__trace_isr_leave>
}
 80014b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80014ba:	f001 bb11 	b.w	8002ae0 <__port_irq_epilogue>
 80014be:	bf00      	nop
 80014c0:	08002d60 	.word	0x08002d60
 80014c4:	40020400 	.word	0x40020400
 80014c8:	2400007c 	.word	0x2400007c
 80014cc:	00000000 	.word	0x00000000

080014d0 <Vector154>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80014d0:	480b      	ldr	r0, [pc, #44]	; (8001500 <Vector154+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 80014d2:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80014d4:	f001 f91c 	bl	8002710 <__trace_isr_enter>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80014d8:	4b0a      	ldr	r3, [pc, #40]	; (8001504 <Vector154+0x34>)
  DMA2->HIFCR = flags << 16U;
  if (dma.streams[14].func)
 80014da:	480b      	ldr	r0, [pc, #44]	; (8001508 <Vector154+0x38>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80014dc:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[14].func)
 80014de:	6f42      	ldr	r2, [r0, #116]	; 0x74
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80014e0:	0c09      	lsrs	r1, r1, #16
 80014e2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 80014e6:	040c      	lsls	r4, r1, #16
 80014e8:	60dc      	str	r4, [r3, #12]
  if (dma.streams[14].func)
 80014ea:	b10a      	cbz	r2, 80014f0 <Vector154+0x20>
    dma.streams[14].func(dma.streams[14].param, flags);
 80014ec:	6f80      	ldr	r0, [r0, #120]	; 0x78
 80014ee:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80014f0:	4803      	ldr	r0, [pc, #12]	; (8001500 <Vector154+0x30>)
 80014f2:	f001 f925 	bl	8002740 <__trace_isr_leave>
}
 80014f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80014fa:	f001 baf1 	b.w	8002ae0 <__port_irq_epilogue>
 80014fe:	bf00      	nop
 8001500:	08002d0c 	.word	0x08002d0c
 8001504:	40020400 	.word	0x40020400
 8001508:	2400007c 	.word	0x2400007c
 800150c:	00000000 	.word	0x00000000

08001510 <Vector158>:
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001510:	480b      	ldr	r0, [pc, #44]	; (8001540 <Vector158+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8001512:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001514:	f001 f8fc 	bl	8002710 <__trace_isr_enter>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001518:	4b0a      	ldr	r3, [pc, #40]	; (8001544 <Vector158+0x34>)
  DMA2->HIFCR = flags << 22U;
  if (dma.streams[15].func)
 800151a:	480b      	ldr	r0, [pc, #44]	; (8001548 <Vector158+0x38>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800151c:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[15].func)
 800151e:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001520:	0d89      	lsrs	r1, r1, #22
 8001522:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 8001526:	058c      	lsls	r4, r1, #22
 8001528:	60dc      	str	r4, [r3, #12]
  if (dma.streams[15].func)
 800152a:	b112      	cbz	r2, 8001532 <Vector158+0x22>
    dma.streams[15].func(dma.streams[15].param, flags);
 800152c:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8001530:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001532:	4803      	ldr	r0, [pc, #12]	; (8001540 <Vector158+0x30>)
 8001534:	f001 f904 	bl	8002740 <__trace_isr_leave>
}
 8001538:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800153c:	f001 bad0 	b.w	8002ae0 <__port_irq_epilogue>
 8001540:	08002d00 	.word	0x08002d00
 8001544:	40020400 	.word	0x40020400
 8001548:	2400007c 	.word	0x2400007c
 800154c:	00000000 	.word	0x00000000

08001550 <otg_enable_ep.constprop.0>:
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
}

static void otg_enable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8001550:	4a12      	ldr	r2, [pc, #72]	; (800159c <otg_enable_ep.constprop.0+0x4c>)
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001552:	2300      	movs	r3, #0
static void otg_enable_ep(USBDriver *usbp) {
 8001554:	b5f0      	push	{r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
 8001556:	e9d2 4124 	ldrd	r4, r1, [r2, #144]	; 0x90
    if (usbp->epc[i]->out_state != NULL) {
      otgp->DAINTMSK |= DAINTMSK_OEPM(i);
 800155a:	f04f 0e01 	mov.w	lr, #1
 800155e:	f102 0c08 	add.w	ip, r2, #8
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001562:	688e      	ldr	r6, [r1, #8]
    if (usbp->epc[i]->out_state != NULL) {
 8001564:	f85c 0f04 	ldr.w	r0, [ip, #4]!
      otgp->DAINTMSK |= DAINTMSK_OEPM(i);
 8001568:	f103 0210 	add.w	r2, r3, #16
    }
    if (usbp->epc[i]->in_state != NULL) {
      otgp->DAINTMSK |= DAINTMSK_IEPM(i);
 800156c:	fa0e f103 	lsl.w	r1, lr, r3
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001570:	1c5d      	adds	r5, r3, #1
    if (usbp->epc[i]->out_state != NULL) {
 8001572:	6987      	ldr	r7, [r0, #24]
      otgp->DAINTMSK |= DAINTMSK_OEPM(i);
 8001574:	fa0e f202 	lsl.w	r2, lr, r2
    if (usbp->epc[i]->out_state != NULL) {
 8001578:	b127      	cbz	r7, 8001584 <otg_enable_ep.constprop.0+0x34>
      otgp->DAINTMSK |= DAINTMSK_OEPM(i);
 800157a:	f8d4 781c 	ldr.w	r7, [r4, #2076]	; 0x81c
 800157e:	433a      	orrs	r2, r7
 8001580:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
    if (usbp->epc[i]->in_state != NULL) {
 8001584:	6942      	ldr	r2, [r0, #20]
 8001586:	b122      	cbz	r2, 8001592 <otg_enable_ep.constprop.0+0x42>
      otgp->DAINTMSK |= DAINTMSK_IEPM(i);
 8001588:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 800158c:	4311      	orrs	r1, r2
 800158e:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001592:	429e      	cmp	r6, r3
 8001594:	462b      	mov	r3, r5
 8001596:	d1e5      	bne.n	8001564 <otg_enable_ep.constprop.0+0x14>
    }
  }
}
 8001598:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800159a:	bf00      	nop
 800159c:	24000100 	.word	0x24000100

080015a0 <otg_disable_ep.isra.0>:
static void otg_disable_ep(USBDriver *usbp) {
 80015a0:	b470      	push	{r4, r5, r6}
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80015a2:	2200      	movs	r2, #0
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80015a4:	f04f 34ff 	mov.w	r4, #4294967295
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80015a8:	688e      	ldr	r6, [r1, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80015aa:	eb00 1142 	add.w	r1, r0, r2, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80015ae:	f102 0c01 	add.w	ip, r2, #1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 80015b2:	f8d1 5900 	ldr.w	r5, [r1, #2304]	; 0x900
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80015b6:	460b      	mov	r3, r1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 80015b8:	2d00      	cmp	r5, #0
 80015ba:	da05      	bge.n	80015c8 <otg_disable_ep.isra.0+0x28>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 80015bc:	f8d1 5900 	ldr.w	r5, [r1, #2304]	; 0x900
 80015c0:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
 80015c4:	f8c1 5900 	str.w	r5, [r1, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 80015c8:	f8d1 5b00 	ldr.w	r5, [r1, #2816]	; 0xb00
 80015cc:	2d00      	cmp	r5, #0
 80015ce:	da05      	bge.n	80015dc <otg_disable_ep.isra.0+0x3c>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 80015d0:	f8d1 5b00 	ldr.w	r5, [r1, #2816]	; 0xb00
 80015d4:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
 80015d8:	f8c1 5b00 	str.w	r5, [r1, #2816]	; 0xb00
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80015dc:	42b2      	cmp	r2, r6
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80015de:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80015e2:	4662      	mov	r2, ip
 80015e4:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80015e8:	d1df      	bne.n	80015aa <otg_disable_ep.isra.0+0xa>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80015ea:	f04f 1301 	mov.w	r3, #65537	; 0x10001
}
 80015ee:	bc70      	pop	{r4, r5, r6}
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80015f0:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
}
 80015f4:	4770      	bx	lr
 80015f6:	bf00      	nop
	...

08001600 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8001600:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001602:	2320      	movs	r3, #32
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8001604:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
void usb_lld_reset(USBDriver *usbp) {
 8001608:	4607      	mov	r7, r0
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800160a:	612b      	str	r3, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800160c:	692c      	ldr	r4, [r5, #16]
 800160e:	f014 0420 	ands.w	r4, r4, #32
 8001612:	d1fb      	bne.n	800160c <usb_lld_reset+0xc>
  chSysPolledDelayX(cycles);
 8001614:	2012      	movs	r0, #18
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8001616:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
 800161a:	f001 f811 	bl	8002640 <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800161e:	f8d7 c094 	ldr.w	ip, [r7, #148]	; 0x94
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8001622:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8001626:	f04f 31ff 	mov.w	r1, #4294967295
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800162a:	f8dc 0008 	ldr.w	r0, [ip, #8]
  otgp->DIEPEMPMSK = 0;
 800162e:	f8c5 4834 	str.w	r4, [r5, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8001632:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8001636:	eb05 1344 	add.w	r3, r5, r4, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800163a:	4284      	cmp	r4, r0
 800163c:	f104 0401 	add.w	r4, r4, #1
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8001640:	f8c3 6900 	str.w	r6, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8001644:	f8c3 6b00 	str.w	r6, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8001648:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800164c:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001650:	d1f1      	bne.n	8001636 <usb_lld_reset+0x36>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8001652:	f8dc 3000 	ldr.w	r3, [ip]
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8001656:	2110      	movs	r1, #16
 8001658:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800165c:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8001660:	626b      	str	r3, [r5, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8001662:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8001664:	6914      	ldr	r4, [r2, #16]
 8001666:	f014 0410 	ands.w	r4, r4, #16
 800166a:	d1fb      	bne.n	8001664 <usb_lld_reset+0x64>
 800166c:	2012      	movs	r0, #18
 800166e:	f000 ffe7 	bl	8002640 <chSysPolledDelayX>
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0) | BOARD_OTG2_ULPI_CHIRP_DELAY_MASK;
 8001672:	f8d5 2800 	ldr.w	r2, [r5, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8001676:	4b12      	ldr	r3, [pc, #72]	; (80016c0 <usb_lld_reset+0xc0>)
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0) | BOARD_OTG2_ULPI_CHIRP_DELAY_MASK;
 8001678:	f422 62fe 	bic.w	r2, r2, #2032	; 0x7f0
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 800167c:	4911      	ldr	r1, [pc, #68]	; (80016c4 <usb_lld_reset+0xc4>)
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0) | BOARD_OTG2_ULPI_CHIRP_DELAY_MASK;
 800167e:	f8c5 2800 	str.w	r2, [r5, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8001682:	69aa      	ldr	r2, [r5, #24]
 8001684:	4313      	orrs	r3, r2
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8001686:	2209      	movs	r2, #9
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8001688:	61ab      	str	r3, [r5, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 800168a:	f8c5 2810 	str.w	r2, [r5, #2064]	; 0x810
  next = usbp->pmnext;
 800168e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8001692:	f8c5 2814 	str.w	r2, [r5, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
 8001696:	60f9      	str	r1, [r7, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 8001698:	f04f 41c0 	mov.w	r1, #1610612736	; 0x60000000
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800169c:	4a0a      	ldr	r2, [pc, #40]	; (80016c8 <usb_lld_reset+0xc8>)
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 800169e:	f8c5 1b10 	str.w	r1, [r5, #2832]	; 0xb10
  usbp->pmnext += size;
 80016a2:	f103 0110 	add.w	r1, r3, #16
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 80016a6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80016aa:	f8c5 2b00 	str.w	r2, [r5, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 80016ae:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 80016b2:	f8c5 2900 	str.w	r2, [r5, #2304]	; 0x900
  usbp->pmnext += size;
 80016b6:	f8c7 1098 	str.w	r1, [r7, #152]	; 0x98
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 80016ba:	62ab      	str	r3, [r5, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 80016bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80016be:	bf00      	nop
 80016c0:	000c0010 	.word	0x000c0010
 80016c4:	08002dcc 	.word	0x08002dcc
 80016c8:	10008040 	.word	0x10008040
 80016cc:	00000000 	.word	0x00000000

080016d0 <usb_lld_set_address>:
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 80016d0:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 80016d4:	f890 108a 	ldrb.w	r1, [r0, #138]	; 0x8a
 80016d8:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 80016dc:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80016e0:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 80016e4:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
}
 80016e8:	4770      	bx	lr
 80016ea:	bf00      	nop
 80016ec:	0000      	movs	r0, r0
	...

080016f0 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 80016f0:	4603      	mov	r3, r0

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 80016f2:	e9d0 0124 	ldrd	r0, r1, [r0, #144]	; 0x90
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80016f6:	680a      	ldr	r2, [r1, #0]
 80016f8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  otg_disable_ep(usbp);
 80016fc:	f7ff bf50 	b.w	80015a0 <otg_disable_ep.isra.0>

08001700 <usb_lld_get_status_out>:
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8001700:	3158      	adds	r1, #88	; 0x58
 8001702:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8001706:	0149      	lsls	r1, r1, #5
 8001708:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 800170a:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 800170e:	d004      	beq.n	800171a <usb_lld_get_status_out+0x1a>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
    return EP_STATUS_STALLED;
 8001710:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8001714:	bf0c      	ite	eq
 8001716:	2002      	moveq	r0, #2
 8001718:	2001      	movne	r0, #1
  return EP_STATUS_ACTIVE;
}
 800171a:	4770      	bx	lr
 800171c:	0000      	movs	r0, r0
	...

08001720 <usb_lld_get_status_in>:
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8001720:	3148      	adds	r1, #72	; 0x48
 8001722:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8001726:	0149      	lsls	r1, r1, #5
 8001728:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 800172a:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 800172e:	d004      	beq.n	800173a <usb_lld_get_status_in+0x1a>
    return EP_STATUS_DISABLED;
  if (ctl & DIEPCTL_STALL)
    return EP_STATUS_STALLED;
 8001730:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8001734:	bf0c      	ite	eq
 8001736:	2002      	moveq	r0, #2
 8001738:	2001      	movne	r0, #1
  return EP_STATUS_ACTIVE;
}
 800173a:	4770      	bx	lr
 800173c:	0000      	movs	r0, r0
	...

08001740 <usb_lld_read_setup>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8001740:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8001744:	68c3      	ldr	r3, [r0, #12]
 8001746:	6a1b      	ldr	r3, [r3, #32]
 8001748:	6819      	ldr	r1, [r3, #0]
 800174a:	685b      	ldr	r3, [r3, #4]
 800174c:	6011      	str	r1, [r2, #0]
 800174e:	6053      	str	r3, [r2, #4]
}
 8001750:	4770      	bx	lr
 8001752:	bf00      	nop
	...

08001760 <usb_lld_start_out>:
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8001760:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8001764:	68da      	ldr	r2, [r3, #12]
 8001766:	6993      	ldr	r3, [r2, #24]
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8001768:	b410      	push	{r4}

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800176a:	681c      	ldr	r4, [r3, #0]
 800176c:	60dc      	str	r4, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 800176e:	b909      	cbnz	r1, 8001774 <usb_lld_start_out+0x14>
 8001770:	2c40      	cmp	r4, #64	; 0x40
 8001772:	d825      	bhi.n	80017c0 <usb_lld_start_out+0x60>
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8001774:	8a53      	ldrh	r3, [r2, #18]
  /* Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8001776:	6812      	ldr	r2, [r2, #0]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8001778:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800177c:	f002 0c03 	and.w	ip, r2, #3
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8001780:	1e5a      	subs	r2, r3, #1
 8001782:	4422      	add	r2, r4
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8001784:	f1bc 0f01 	cmp.w	ip, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8001788:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 800178c:	fb02 f303 	mul.w	r3, r2, r3
 8001790:	f103 0303 	add.w	r3, r3, #3
 8001794:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8001798:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 800179c:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 80017a0:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 80017a4:	f8c2 3b10 	str.w	r3, [r2, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80017a8:	d00d      	beq.n	80017c6 <usb_lld_start_out+0x66>
 80017aa:	b209      	sxth	r1, r1
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 80017ac:	eb00 1041 	add.w	r0, r0, r1, lsl #5
}
 80017b0:	bc10      	pop	{r4}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 80017b2:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80017b6:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80017ba:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 80017be:	4770      	bx	lr
    osp->rxsize = EP0_MAX_OUTSIZE;
 80017c0:	2440      	movs	r4, #64	; 0x40
 80017c2:	601c      	str	r4, [r3, #0]
 80017c4:	e7d6      	b.n	8001774 <usb_lld_start_out+0x14>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80017c6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80017ca:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 80017ce:	b209      	sxth	r1, r1
 80017d0:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80017d4:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 80017d8:	bf14      	ite	ne
 80017da:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80017de:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 80017e2:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 80017e6:	e7e1      	b.n	80017ac <usb_lld_start_out+0x4c>
	...

080017f0 <otg_epout_handler.constprop.0>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 80017f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 80017f4:	4f24      	ldr	r7, [pc, #144]	; (8001888 <otg_epout_handler.constprop.0+0x98>)
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 80017f6:	4604      	mov	r4, r0
  stm32_otg_t *otgp = usbp->otg;
 80017f8:	f8d7 6090 	ldr.w	r6, [r7, #144]	; 0x90
  uint32_t epint = otgp->oe[ep].DOEPINT;
 80017fc:	eb06 1340 	add.w	r3, r6, r0, lsl #5
 8001800:	f8d3 5b08 	ldr.w	r5, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8001804:	0728      	lsls	r0, r5, #28
  otgp->oe[ep].DOEPINT = epint;
 8001806:	f8c3 5b08 	str.w	r5, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 800180a:	d503      	bpl.n	8001814 <otg_epout_handler.constprop.0+0x24>
 800180c:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8001810:	0719      	lsls	r1, r3, #28
 8001812:	d431      	bmi.n	8001878 <otg_epout_handler.constprop.0+0x88>
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8001814:	07ea      	lsls	r2, r5, #31
 8001816:	d52d      	bpl.n	8001874 <otg_epout_handler.constprop.0+0x84>
 8001818:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 800181c:	07db      	lsls	r3, r3, #31
 800181e:	d529      	bpl.n	8001874 <otg_epout_handler.constprop.0+0x84>
    osp = usbp->epc[ep]->out_state;
 8001820:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 8001824:	68d9      	ldr	r1, [r3, #12]
 8001826:	698a      	ldr	r2, [r1, #24]
    if (ep == 0) {
 8001828:	b954      	cbnz	r4, 8001840 <otg_epout_handler.constprop.0+0x50>
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800182a:	8a48      	ldrh	r0, [r1, #18]
 800182c:	6853      	ldr	r3, [r2, #4]
 800182e:	fbb3 f5f0 	udiv	r5, r3, r0
 8001832:	fb00 3315 	mls	r3, r0, r5, r3
 8001836:	b91b      	cbnz	r3, 8001840 <otg_epout_handler.constprop.0+0x50>
          (osp->rxsize < osp->totsize)) {
 8001838:	6810      	ldr	r0, [r2, #0]
 800183a:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800183c:	4298      	cmp	r0, r3
 800183e:	d30d      	bcc.n	800185c <otg_epout_handler.constprop.0+0x6c>
    _usb_isr_invoke_out_cb(usbp, ep);
 8001840:	2201      	movs	r2, #1
 8001842:	897b      	ldrh	r3, [r7, #10]
 8001844:	68cd      	ldr	r5, [r1, #12]
 8001846:	40a2      	lsls	r2, r4
 8001848:	ea23 0302 	bic.w	r3, r3, r2
 800184c:	817b      	strh	r3, [r7, #10]
 800184e:	b18d      	cbz	r5, 8001874 <otg_epout_handler.constprop.0+0x84>
 8001850:	4621      	mov	r1, r4
 8001852:	462b      	mov	r3, r5
 8001854:	480c      	ldr	r0, [pc, #48]	; (8001888 <otg_epout_handler.constprop.0+0x98>)
}
 8001856:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
 800185a:	4718      	bx	r3
        osp->rxsize = osp->totsize - osp->rxsize;
 800185c:	1a1b      	subs	r3, r3, r0
        osp->rxcnt  = 0;
 800185e:	6054      	str	r4, [r2, #4]
 8001860:	2130      	movs	r1, #48	; 0x30
        osp->rxsize = osp->totsize - osp->rxsize;
 8001862:	6013      	str	r3, [r2, #0]
 8001864:	f381 8811 	msr	BASEPRI, r1
        usb_lld_start_out(usbp, ep);
 8001868:	4807      	ldr	r0, [pc, #28]	; (8001888 <otg_epout_handler.constprop.0+0x98>)
 800186a:	4621      	mov	r1, r4
 800186c:	f7ff ff78 	bl	8001760 <usb_lld_start_out>
 8001870:	f384 8811 	msr	BASEPRI, r4
}
 8001874:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_setup_cb(usbp, ep);
 8001878:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 800187c:	4621      	mov	r1, r4
 800187e:	4638      	mov	r0, r7
 8001880:	68db      	ldr	r3, [r3, #12]
 8001882:	685b      	ldr	r3, [r3, #4]
 8001884:	4798      	blx	r3
 8001886:	e7c5      	b.n	8001814 <otg_epout_handler.constprop.0+0x24>
 8001888:	24000100 	.word	0x24000100
 800188c:	00000000 	.word	0x00000000

08001890 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8001890:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8001894:	b410      	push	{r4}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8001896:	68dc      	ldr	r4, [r3, #12]
 8001898:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800189a:	6813      	ldr	r3, [r2, #0]
 800189c:	60d3      	str	r3, [r2, #12]
  if (isp->txsize == 0) {
 800189e:	b9f3      	cbnz	r3, 80018de <usb_lld_start_in+0x4e>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 80018a0:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 80018a4:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80018a8:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 80018ac:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80018b0:	6823      	ldr	r3, [r4, #0]
 80018b2:	f003 0303 	and.w	r3, r3, #3
 80018b6:	2b01      	cmp	r3, #1
 80018b8:	d02a      	beq.n	8001910 <usb_lld_start_in+0x80>
 80018ba:	b208      	sxth	r0, r1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80018bc:	eb02 1040 	add.w	r0, r2, r0, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80018c0:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80018c2:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80018c6:	408b      	lsls	r3, r1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80018c8:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80018cc:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80018d0:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
}
 80018d4:	bc10      	pop	{r4}
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80018d6:	430b      	orrs	r3, r1
 80018d8:	f8c2 3834 	str.w	r3, [r2, #2100]	; 0x834
}
 80018dc:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 80018de:	b909      	cbnz	r1, 80018e4 <usb_lld_start_in+0x54>
 80018e0:	2b40      	cmp	r3, #64	; 0x40
 80018e2:	d826      	bhi.n	8001932 <usb_lld_start_in+0xa2>
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80018e4:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80018e8:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80018ec:	f10c 30ff 	add.w	r0, ip, #4294967295
 80018f0:	4418      	add	r0, r3
 80018f2:	fbb0 f0fc 	udiv	r0, r0, ip
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80018f6:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
 80018fa:	eb02 1041 	add.w	r0, r2, r1, lsl #5
 80018fe:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001902:	f8c0 3910 	str.w	r3, [r0, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8001906:	6823      	ldr	r3, [r4, #0]
 8001908:	f003 0303 	and.w	r3, r3, #3
 800190c:	2b01      	cmp	r3, #1
 800190e:	d1d4      	bne.n	80018ba <usb_lld_start_in+0x2a>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8001910:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
 8001914:	b208      	sxth	r0, r1
 8001916:	f413 7f80 	tst.w	r3, #256	; 0x100
 800191a:	eb02 1341 	add.w	r3, r2, r1, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 800191e:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 8001922:	bf14      	ite	ne
 8001924:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8001928:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
 800192c:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
 8001930:	e7c4      	b.n	80018bc <usb_lld_start_in+0x2c>
      isp->txsize = EP0_MAX_INSIZE;
 8001932:	2340      	movs	r3, #64	; 0x40
 8001934:	6013      	str	r3, [r2, #0]
 8001936:	e7d5      	b.n	80018e4 <usb_lld_start_in+0x54>
	...

08001940 <otg_epin_handler.constprop.0>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8001940:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
 8001944:	f8df 9104 	ldr.w	r9, [pc, #260]	; 8001a4c <otg_epin_handler.constprop.0+0x10c>
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8001948:	4604      	mov	r4, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800194a:	ea4f 1b40 	mov.w	fp, r0, lsl #5
  stm32_otg_t *otgp = usbp->otg;
 800194e:	f8d9 6090 	ldr.w	r6, [r9, #144]	; 0x90
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8001952:	eb06 1340 	add.w	r3, r6, r0, lsl #5
 8001956:	f8d3 5908 	ldr.w	r5, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 800195a:	07e9      	lsls	r1, r5, #31
  otgp->ie[ep].DIEPINT = epint;
 800195c:	f8c3 5908 	str.w	r5, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8001960:	d503      	bpl.n	800196a <otg_epin_handler.constprop.0+0x2a>
 8001962:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 8001966:	07da      	lsls	r2, r3, #31
 8001968:	d40c      	bmi.n	8001984 <otg_epin_handler.constprop.0+0x44>
  if ((epint & DIEPINT_TXFE) &&
 800196a:	062b      	lsls	r3, r5, #24
 800196c:	d508      	bpl.n	8001980 <otg_epin_handler.constprop.0+0x40>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800196e:	f04f 0801 	mov.w	r8, #1
 8001972:	f8d6 3834 	ldr.w	r3, [r6, #2100]	; 0x834
 8001976:	fa08 f804 	lsl.w	r8, r8, r4
  if ((epint & DIEPINT_TXFE) &&
 800197a:	ea13 0f08 	tst.w	r3, r8
 800197e:	d118      	bne.n	80019b2 <otg_epin_handler.constprop.0+0x72>
}
 8001980:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8001984:	eb09 0380 	add.w	r3, r9, r0, lsl #2
 8001988:	68d9      	ldr	r1, [r3, #12]
 800198a:	694b      	ldr	r3, [r1, #20]
    if (isp->txsize < isp->totsize) {
 800198c:	6818      	ldr	r0, [r3, #0]
 800198e:	68da      	ldr	r2, [r3, #12]
 8001990:	4290      	cmp	r0, r2
 8001992:	d34a      	bcc.n	8001a2a <otg_epin_handler.constprop.0+0xea>
      _usb_isr_invoke_in_cb(usbp, ep);
 8001994:	2201      	movs	r2, #1
 8001996:	f8b9 3008 	ldrh.w	r3, [r9, #8]
 800199a:	688f      	ldr	r7, [r1, #8]
 800199c:	40a2      	lsls	r2, r4
 800199e:	ea23 0302 	bic.w	r3, r3, r2
 80019a2:	f8a9 3008 	strh.w	r3, [r9, #8]
 80019a6:	2f00      	cmp	r7, #0
 80019a8:	d0df      	beq.n	800196a <otg_epin_handler.constprop.0+0x2a>
 80019aa:	4621      	mov	r1, r4
 80019ac:	4648      	mov	r0, r9
 80019ae:	47b8      	blx	r7
 80019b0:	e7db      	b.n	800196a <otg_epin_handler.constprop.0+0x2a>
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 80019b2:	eb09 0384 	add.w	r3, r9, r4, lsl #2
 80019b6:	68db      	ldr	r3, [r3, #12]
 80019b8:	695e      	ldr	r6, [r3, #20]
 80019ba:	e9d6 7500 	ldrd	r7, r5, [r6]
 80019be:	42af      	cmp	r7, r5
 80019c0:	d941      	bls.n	8001a46 <otg_epin_handler.constprop.0+0x106>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80019c2:	3401      	adds	r4, #1
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80019c4:	f8d9 a090 	ldr.w	sl, [r9, #144]	; 0x90
    if (n > usbp->epc[ep]->in_maxsize)
 80019c8:	f8b3 9010 	ldrh.w	r9, [r3, #16]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80019cc:	b2e4      	uxtb	r4, r4
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80019ce:	eb0a 0e0b 	add.w	lr, sl, fp
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80019d2:	eb0a 3004 	add.w	r0, sl, r4, lsl #12
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 80019d6:	eba7 0c05 	sub.w	ip, r7, r5
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80019da:	f8de 3918 	ldr.w	r3, [lr, #2328]	; 0x918
 80019de:	45cc      	cmp	ip, r9
 80019e0:	b29b      	uxth	r3, r3
 80019e2:	bf28      	it	cs
 80019e4:	46cc      	movcs	ip, r9
 80019e6:	ebbc 0f83 	cmp.w	ip, r3, lsl #2
 80019ea:	d8c9      	bhi.n	8001980 <otg_epin_handler.constprop.0+0x40>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80019ec:	68b4      	ldr	r4, [r6, #8]
    if (n <= 4) {
 80019ee:	f1bc 0f04 	cmp.w	ip, #4
    *fifop = *((uint32_t *)buf);
 80019f2:	6823      	ldr	r3, [r4, #0]
 80019f4:	6003      	str	r3, [r0, #0]
    if (n <= 4) {
 80019f6:	d90b      	bls.n	8001a10 <otg_epin_handler.constprop.0+0xd0>
 80019f8:	f1ac 0105 	sub.w	r1, ip, #5
 80019fc:	4623      	mov	r3, r4
 80019fe:	f021 0103 	bic.w	r1, r1, #3
 8001a02:	3104      	adds	r1, #4
 8001a04:	4421      	add	r1, r4
    *fifop = *((uint32_t *)buf);
 8001a06:	f853 2f04 	ldr.w	r2, [r3, #4]!
    if (n <= 4) {
 8001a0a:	4299      	cmp	r1, r3
    *fifop = *((uint32_t *)buf);
 8001a0c:	6002      	str	r2, [r0, #0]
    if (n <= 4) {
 8001a0e:	d1fa      	bne.n	8001a06 <otg_epin_handler.constprop.0+0xc6>
    usbp->epc[ep]->in_state->txcnt += n;
 8001a10:	4465      	add	r5, ip
    usbp->epc[ep]->in_state->txbuf += n;
 8001a12:	4464      	add	r4, ip
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8001a14:	42bd      	cmp	r5, r7
    usbp->epc[ep]->in_state->txcnt += n;
 8001a16:	e9c6 5401 	strd	r5, r4, [r6, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8001a1a:	d3dc      	bcc.n	80019d6 <otg_epin_handler.constprop.0+0x96>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8001a1c:	f8da 3834 	ldr.w	r3, [sl, #2100]	; 0x834
 8001a20:	ea23 0308 	bic.w	r3, r3, r8
 8001a24:	f8ca 3834 	str.w	r3, [sl, #2100]	; 0x834
      return true;
 8001a28:	e7aa      	b.n	8001980 <otg_epin_handler.constprop.0+0x40>
      isp->txsize = isp->totsize - isp->txsize;
 8001a2a:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 8001a2c:	2700      	movs	r7, #0
      isp->txsize = isp->totsize - isp->txsize;
 8001a2e:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 8001a30:	605f      	str	r7, [r3, #4]
 8001a32:	2330      	movs	r3, #48	; 0x30
 8001a34:	f383 8811 	msr	BASEPRI, r3
      usb_lld_start_in(usbp, ep);
 8001a38:	4621      	mov	r1, r4
 8001a3a:	4648      	mov	r0, r9
 8001a3c:	f7ff ff28 	bl	8001890 <usb_lld_start_in>
 8001a40:	f387 8811 	msr	BASEPRI, r7
}
 8001a44:	e791      	b.n	800196a <otg_epin_handler.constprop.0+0x2a>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8001a46:	f8d9 a090 	ldr.w	sl, [r9, #144]	; 0x90
 8001a4a:	e7e7      	b.n	8001a1c <otg_epin_handler.constprop.0+0xdc>
 8001a4c:	24000100 	.word	0x24000100

08001a50 <Vector1D4>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8001a50:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
 8001a54:	4eb2      	ldr	r6, [pc, #712]	; (8001d20 <Vector1D4+0x2d0>)
 8001a56:	f04f 0940 	mov.w	r9, #64	; 0x40
  OSAL_IRQ_PROLOGUE();
 8001a5a:	48b2      	ldr	r0, [pc, #712]	; (8001d24 <Vector1D4+0x2d4>)
 8001a5c:	f000 fe58 	bl	8002710 <__trace_isr_enter>
  stm32_otg_t *otgp = usbp->otg;
 8001a60:	f8d6 7090 	ldr.w	r7, [r6, #144]	; 0x90
  unsigned retry = 64U;
 8001a64:	e06e      	b.n	8001b44 <Vector1D4+0xf4>
  if (sts & GINTSTS_USBSUSP) {
 8001a66:	0529      	lsls	r1, r5, #20
 8001a68:	f100 808e 	bmi.w	8001b88 <Vector1D4+0x138>
  if (sts & GINTSTS_ENUMDNE) {
 8001a6c:	04aa      	lsls	r2, r5, #18
 8001a6e:	d50c      	bpl.n	8001a8a <Vector1D4+0x3a>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8001a70:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
 8001a74:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8001a78:	68fb      	ldr	r3, [r7, #12]
 8001a7a:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8001a7e:	bf0c      	ite	eq
 8001a80:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8001a84:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 8001a88:	60fb      	str	r3, [r7, #12]
  if (sts & GINTSTS_SOF) {
 8001a8a:	072b      	lsls	r3, r5, #28
 8001a8c:	d50e      	bpl.n	8001aac <Vector1D4+0x5c>
    if (usbp->config->sof_cb == NULL) {
 8001a8e:	6874      	ldr	r4, [r6, #4]
 8001a90:	68e3      	ldr	r3, [r4, #12]
 8001a92:	2b00      	cmp	r3, #0
 8001a94:	f000 8176 	beq.w	8001d84 <Vector1D4+0x334>
    if (usbp->state == USB_SUSPENDED) {
 8001a98:	7833      	ldrb	r3, [r6, #0]
 8001a9a:	2b05      	cmp	r3, #5
 8001a9c:	f000 817a 	beq.w	8001d94 <Vector1D4+0x344>
    otg_enable_ep(usbp);
 8001aa0:	f7ff fd56 	bl	8001550 <otg_enable_ep.constprop.0>
    _usb_isr_invoke_sof_cb(usbp);
 8001aa4:	68e3      	ldr	r3, [r4, #12]
 8001aa6:	b10b      	cbz	r3, 8001aac <Vector1D4+0x5c>
 8001aa8:	4630      	mov	r0, r6
 8001aaa:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 8001aac:	02ec      	lsls	r4, r5, #11
 8001aae:	d473      	bmi.n	8001b98 <Vector1D4+0x148>
  if (sts & GINTSTS_IISOOXFR) {
 8001ab0:	02a8      	lsls	r0, r5, #10
 8001ab2:	f100 80b4 	bmi.w	8001c1e <Vector1D4+0x1ce>
  if (sts & GINTSTS_OEPINT) {
 8001ab6:	032b      	lsls	r3, r5, #12
  src = otgp->DAINT;
 8001ab8:	f8d7 4818 	ldr.w	r4, [r7, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 8001abc:	d51a      	bpl.n	8001af4 <Vector1D4+0xa4>
    if (src & (1 << 16))
 8001abe:	03e0      	lsls	r0, r4, #15
 8001ac0:	f100 813c 	bmi.w	8001d3c <Vector1D4+0x2ec>
    if (src & (1 << 17))
 8001ac4:	03a1      	lsls	r1, r4, #14
 8001ac6:	f100 8135 	bmi.w	8001d34 <Vector1D4+0x2e4>
    if (src & (1 << 18))
 8001aca:	0362      	lsls	r2, r4, #13
 8001acc:	f100 812e 	bmi.w	8001d2c <Vector1D4+0x2dc>
    if (src & (1 << 19))
 8001ad0:	0323      	lsls	r3, r4, #12
 8001ad2:	f100 8120 	bmi.w	8001d16 <Vector1D4+0x2c6>
    if (src & (1 << 20))
 8001ad6:	02e0      	lsls	r0, r4, #11
 8001ad8:	f100 8119 	bmi.w	8001d0e <Vector1D4+0x2be>
    if (src & (1 << 21))
 8001adc:	02a1      	lsls	r1, r4, #10
 8001ade:	f100 8112 	bmi.w	8001d06 <Vector1D4+0x2b6>
    if (src & (1 << 22))
 8001ae2:	0262      	lsls	r2, r4, #9
 8001ae4:	f100 810b 	bmi.w	8001cfe <Vector1D4+0x2ae>
    if (src & (1 << 23))
 8001ae8:	0223      	lsls	r3, r4, #8
 8001aea:	f100 8104 	bmi.w	8001cf6 <Vector1D4+0x2a6>
    if (src & (1 << 24))
 8001aee:	01e0      	lsls	r0, r4, #7
 8001af0:	f100 80f9 	bmi.w	8001ce6 <Vector1D4+0x296>
  if (sts & GINTSTS_IEPINT) {
 8001af4:	0369      	lsls	r1, r5, #13
 8001af6:	d51a      	bpl.n	8001b2e <Vector1D4+0xde>
    if (src & (1 << 0))
 8001af8:	07e2      	lsls	r2, r4, #31
 8001afa:	f100 813f 	bmi.w	8001d7c <Vector1D4+0x32c>
    if (src & (1 << 1))
 8001afe:	07a3      	lsls	r3, r4, #30
 8001b00:	f100 8138 	bmi.w	8001d74 <Vector1D4+0x324>
    if (src & (1 << 2))
 8001b04:	0760      	lsls	r0, r4, #29
 8001b06:	f100 8131 	bmi.w	8001d6c <Vector1D4+0x31c>
    if (src & (1 << 3))
 8001b0a:	0721      	lsls	r1, r4, #28
 8001b0c:	f100 812a 	bmi.w	8001d64 <Vector1D4+0x314>
    if (src & (1 << 4))
 8001b10:	06e2      	lsls	r2, r4, #27
 8001b12:	f100 8123 	bmi.w	8001d5c <Vector1D4+0x30c>
    if (src & (1 << 5))
 8001b16:	06a3      	lsls	r3, r4, #26
 8001b18:	f100 811c 	bmi.w	8001d54 <Vector1D4+0x304>
    if (src & (1 << 6))
 8001b1c:	0660      	lsls	r0, r4, #25
 8001b1e:	f100 8115 	bmi.w	8001d4c <Vector1D4+0x2fc>
    if (src & (1 << 7))
 8001b22:	0621      	lsls	r1, r4, #24
 8001b24:	f100 810e 	bmi.w	8001d44 <Vector1D4+0x2f4>
    if (src & (1 << 8))
 8001b28:	05e2      	lsls	r2, r4, #23
 8001b2a:	f100 80e0 	bmi.w	8001cee <Vector1D4+0x29e>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8001b2e:	06eb      	lsls	r3, r5, #27
 8001b30:	f100 80a2 	bmi.w	8001c78 <Vector1D4+0x228>
  if ((sts & IRQ_RETRY_MASK) && (--retry > 0U))
 8001b34:	4b7c      	ldr	r3, [pc, #496]	; (8001d28 <Vector1D4+0x2d8>)
 8001b36:	421d      	tst	r5, r3
 8001b38:	f000 80ce 	beq.w	8001cd8 <Vector1D4+0x288>
 8001b3c:	f1b9 0901 	subs.w	r9, r9, #1
 8001b40:	f000 80ca 	beq.w	8001cd8 <Vector1D4+0x288>
  sts  = otgp->GINTSTS;
 8001b44:	697d      	ldr	r5, [r7, #20]
  sts &= otgp->GINTMSK;
 8001b46:	69bb      	ldr	r3, [r7, #24]
 8001b48:	401d      	ands	r5, r3
  if (sts & GINTSTS_USBRST) {
 8001b4a:	f415 5880 	ands.w	r8, r5, #4096	; 0x1000
  otgp->GINTSTS = sts;
 8001b4e:	617d      	str	r5, [r7, #20]
  if (sts & GINTSTS_USBRST) {
 8001b50:	f040 815f 	bne.w	8001e12 <Vector1D4+0x3c2>
  if (sts & GINTSTS_WKUPINT) {
 8001b54:	2d00      	cmp	r5, #0
 8001b56:	da86      	bge.n	8001a66 <Vector1D4+0x16>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8001b58:	f8d7 3e00 	ldr.w	r3, [r7, #3584]	; 0xe00
 8001b5c:	0798      	lsls	r0, r3, #30
 8001b5e:	d005      	beq.n	8001b6c <Vector1D4+0x11c>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8001b60:	f8d7 3e00 	ldr.w	r3, [r7, #3584]	; 0xe00
 8001b64:	f023 0303 	bic.w	r3, r3, #3
 8001b68:	f8c7 3e00 	str.w	r3, [r7, #3584]	; 0xe00
    otg_enable_ep(usbp);
 8001b6c:	f7ff fcf0 	bl	8001550 <otg_enable_ep.constprop.0>
    otgp->DCTL &= ~DCTL_RWUSIG;
 8001b70:	f8d7 3804 	ldr.w	r3, [r7, #2052]	; 0x804
    _usb_wakeup(usbp);
 8001b74:	4630      	mov	r0, r6
    otgp->DCTL &= ~DCTL_RWUSIG;
 8001b76:	f023 0301 	bic.w	r3, r3, #1
 8001b7a:	f8c7 3804 	str.w	r3, [r7, #2052]	; 0x804
    _usb_wakeup(usbp);
 8001b7e:	f7fe fda7 	bl	80006d0 <_usb_wakeup>
  if (sts & GINTSTS_USBSUSP) {
 8001b82:	0529      	lsls	r1, r5, #20
 8001b84:	f57f af72 	bpl.w	8001a6c <Vector1D4+0x1c>
    otg_disable_ep(usbp);
 8001b88:	e9d6 0124 	ldrd	r0, r1, [r6, #144]	; 0x90
 8001b8c:	f7ff fd08 	bl	80015a0 <otg_disable_ep.isra.0>
    _usb_suspend(usbp);
 8001b90:	4630      	mov	r0, r6
 8001b92:	f7fe fd85 	bl	80006a0 <_usb_suspend>
 8001b96:	e769      	b.n	8001a6c <Vector1D4+0x1c>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001b98:	2100      	movs	r1, #0
  stm32_otg_t *otgp = usbp->otg;
 8001b9a:	f8d6 b090 	ldr.w	fp, [r6, #144]	; 0x90
      _usb_isr_invoke_in_cb(usbp, ep);
 8001b9e:	f04f 0a01 	mov.w	sl, #1
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001ba2:	460c      	mov	r4, r1
 8001ba4:	e008      	b.n	8001bb8 <Vector1D4+0x168>
 8001ba6:	3401      	adds	r4, #1
 8001ba8:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8001bac:	b2e4      	uxtb	r4, r4
 8001bae:	689b      	ldr	r3, [r3, #8]
 8001bb0:	429c      	cmp	r4, r3
 8001bb2:	4621      	mov	r1, r4
 8001bb4:	f63f af7c 	bhi.w	8001ab0 <Vector1D4+0x60>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8001bb8:	eb0b 1244 	add.w	r2, fp, r4, lsl #5
 8001bbc:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8001bc0:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8001bc4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001bc8:	d1ed      	bne.n	8001ba6 <Vector1D4+0x156>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8001bca:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8001bce:	2b00      	cmp	r3, #0
 8001bd0:	dae9      	bge.n	8001ba6 <Vector1D4+0x156>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8001bd2:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8001bd6:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
 8001bda:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8001bde:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8001be2:	2b00      	cmp	r3, #0
 8001be4:	dbfb      	blt.n	8001bde <Vector1D4+0x18e>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001be6:	0189      	lsls	r1, r1, #6
 8001be8:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 8001bec:	f041 0120 	orr.w	r1, r1, #32
 8001bf0:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8001bf2:	6913      	ldr	r3, [r2, #16]
 8001bf4:	0699      	lsls	r1, r3, #26
 8001bf6:	d4fc      	bmi.n	8001bf2 <Vector1D4+0x1a2>
  chSysPolledDelayX(cycles);
 8001bf8:	2012      	movs	r0, #18
 8001bfa:	f000 fd21 	bl	8002640 <chSysPolledDelayX>
      _usb_isr_invoke_in_cb(usbp, ep);
 8001bfe:	8933      	ldrh	r3, [r6, #8]
 8001c00:	eb06 0284 	add.w	r2, r6, r4, lsl #2
 8001c04:	fa0a f104 	lsl.w	r1, sl, r4
 8001c08:	68d2      	ldr	r2, [r2, #12]
 8001c0a:	ea23 0301 	bic.w	r3, r3, r1
 8001c0e:	6892      	ldr	r2, [r2, #8]
 8001c10:	8133      	strh	r3, [r6, #8]
 8001c12:	2a00      	cmp	r2, #0
 8001c14:	d0c7      	beq.n	8001ba6 <Vector1D4+0x156>
 8001c16:	4621      	mov	r1, r4
 8001c18:	4630      	mov	r0, r6
 8001c1a:	4790      	blx	r2
 8001c1c:	e7c3      	b.n	8001ba6 <Vector1D4+0x156>
  stm32_otg_t *otgp = usbp->otg;
 8001c1e:	f8d6 a090 	ldr.w	sl, [r6, #144]	; 0x90
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001c22:	2400      	movs	r4, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 8001c24:	f04f 0b01 	mov.w	fp, #1
 8001c28:	e007      	b.n	8001c3a <Vector1D4+0x1ea>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001c2a:	3401      	adds	r4, #1
 8001c2c:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8001c30:	b2e4      	uxtb	r4, r4
 8001c32:	689b      	ldr	r3, [r3, #8]
 8001c34:	429c      	cmp	r4, r3
 8001c36:	f63f af3e 	bhi.w	8001ab6 <Vector1D4+0x66>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8001c3a:	eb0a 1244 	add.w	r2, sl, r4, lsl #5
 8001c3e:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8001c42:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8001c46:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001c4a:	d1ee      	bne.n	8001c2a <Vector1D4+0x1da>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8001c4c:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
      _usb_isr_invoke_out_cb(usbp, ep);
 8001c50:	eb06 0184 	add.w	r1, r6, r4, lsl #2
 8001c54:	fa0b f204 	lsl.w	r2, fp, r4
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8001c58:	2b00      	cmp	r3, #0
 8001c5a:	dae6      	bge.n	8001c2a <Vector1D4+0x1da>
      _usb_isr_invoke_out_cb(usbp, ep);
 8001c5c:	8973      	ldrh	r3, [r6, #10]
 8001c5e:	4630      	mov	r0, r6
 8001c60:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 8001c64:	4621      	mov	r1, r4
 8001c66:	ea23 0302 	bic.w	r3, r3, r2
 8001c6a:	f8dc 200c 	ldr.w	r2, [ip, #12]
 8001c6e:	8173      	strh	r3, [r6, #10]
 8001c70:	2a00      	cmp	r2, #0
 8001c72:	d0da      	beq.n	8001c2a <Vector1D4+0x1da>
 8001c74:	4790      	blx	r2
 8001c76:	e7d8      	b.n	8001c2a <Vector1D4+0x1da>
  sts = usbp->otg->GRXSTSP;
 8001c78:	f8d6 1090 	ldr.w	r1, [r6, #144]	; 0x90
 8001c7c:	6a0b      	ldr	r3, [r1, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8001c7e:	f403 10f0 	and.w	r0, r3, #1966080	; 0x1e0000
  n  = (size_t)((sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF);
 8001c82:	f3c3 120a 	ubfx	r2, r3, #4, #11
  ep = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8001c86:	f003 030f 	and.w	r3, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8001c8a:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8001c8e:	f000 808c 	beq.w	8001daa <Vector1D4+0x35a>
 8001c92:	f5b0 2f40 	cmp.w	r0, #786432	; 0xc0000
 8001c96:	f47f af4d 	bne.w	8001b34 <Vector1D4+0xe4>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8001c9a:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8001c9e:	68db      	ldr	r3, [r3, #12]
 8001ca0:	6a18      	ldr	r0, [r3, #32]
  while (i < n) {
 8001ca2:	2a00      	cmp	r2, #0
 8001ca4:	f43f af46 	beq.w	8001b34 <Vector1D4+0xe4>
      w = *fifop;
 8001ca8:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
  size_t i = 0;
 8001cac:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 8001cae:	f013 0f03 	tst.w	r3, #3
      *buf++ = (uint8_t)w;
 8001cb2:	4601      	mov	r1, r0
    if ((i & 3) == 0) {
 8001cb4:	d101      	bne.n	8001cba <Vector1D4+0x26a>
      w = *fifop;
 8001cb6:	f8d4 8000 	ldr.w	r8, [r4]
    if (i < max) {
 8001cba:	2b07      	cmp	r3, #7
    i++;
 8001cbc:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 8001cc0:	d804      	bhi.n	8001ccc <Vector1D4+0x27c>
      *buf++ = (uint8_t)w;
 8001cc2:	f801 8b01 	strb.w	r8, [r1], #1
      w >>= 8;
 8001cc6:	ea4f 2818 	mov.w	r8, r8, lsr #8
      *buf++ = (uint8_t)w;
 8001cca:	4608      	mov	r0, r1
  while (i < n) {
 8001ccc:	429a      	cmp	r2, r3
 8001cce:	d1ee      	bne.n	8001cae <Vector1D4+0x25e>
  if ((sts & IRQ_RETRY_MASK) && (--retry > 0U))
 8001cd0:	4b15      	ldr	r3, [pc, #84]	; (8001d28 <Vector1D4+0x2d8>)
 8001cd2:	421d      	tst	r5, r3
 8001cd4:	f47f af32 	bne.w	8001b3c <Vector1D4+0xec>
  OSAL_IRQ_EPILOGUE();
 8001cd8:	4812      	ldr	r0, [pc, #72]	; (8001d24 <Vector1D4+0x2d4>)
 8001cda:	f000 fd31 	bl	8002740 <__trace_isr_leave>
}
 8001cde:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8001ce2:	f000 befd 	b.w	8002ae0 <__port_irq_epilogue>
      otg_epout_handler(usbp, 8);
 8001ce6:	2008      	movs	r0, #8
 8001ce8:	f7ff fd82 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001cec:	e702      	b.n	8001af4 <Vector1D4+0xa4>
      otg_epin_handler(usbp, 8);
 8001cee:	2008      	movs	r0, #8
 8001cf0:	f7ff fe26 	bl	8001940 <otg_epin_handler.constprop.0>
 8001cf4:	e71b      	b.n	8001b2e <Vector1D4+0xde>
      otg_epout_handler(usbp, 7);
 8001cf6:	2007      	movs	r0, #7
 8001cf8:	f7ff fd7a 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001cfc:	e6f7      	b.n	8001aee <Vector1D4+0x9e>
      otg_epout_handler(usbp, 6);
 8001cfe:	2006      	movs	r0, #6
 8001d00:	f7ff fd76 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001d04:	e6f0      	b.n	8001ae8 <Vector1D4+0x98>
      otg_epout_handler(usbp, 5);
 8001d06:	2005      	movs	r0, #5
 8001d08:	f7ff fd72 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001d0c:	e6e9      	b.n	8001ae2 <Vector1D4+0x92>
      otg_epout_handler(usbp, 4);
 8001d0e:	2004      	movs	r0, #4
 8001d10:	f7ff fd6e 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001d14:	e6e2      	b.n	8001adc <Vector1D4+0x8c>
      otg_epout_handler(usbp, 3);
 8001d16:	2003      	movs	r0, #3
 8001d18:	f7ff fd6a 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001d1c:	e6db      	b.n	8001ad6 <Vector1D4+0x86>
 8001d1e:	bf00      	nop
 8001d20:	24000100 	.word	0x24000100
 8001d24:	08002dc0 	.word	0x08002dc0
 8001d28:	04000030 	.word	0x04000030
      otg_epout_handler(usbp, 2);
 8001d2c:	2002      	movs	r0, #2
 8001d2e:	f7ff fd5f 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001d32:	e6cd      	b.n	8001ad0 <Vector1D4+0x80>
      otg_epout_handler(usbp, 1);
 8001d34:	2001      	movs	r0, #1
 8001d36:	f7ff fd5b 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001d3a:	e6c6      	b.n	8001aca <Vector1D4+0x7a>
      otg_epout_handler(usbp, 0);
 8001d3c:	2000      	movs	r0, #0
 8001d3e:	f7ff fd57 	bl	80017f0 <otg_epout_handler.constprop.0>
 8001d42:	e6bf      	b.n	8001ac4 <Vector1D4+0x74>
      otg_epin_handler(usbp, 7);
 8001d44:	2007      	movs	r0, #7
 8001d46:	f7ff fdfb 	bl	8001940 <otg_epin_handler.constprop.0>
 8001d4a:	e6ed      	b.n	8001b28 <Vector1D4+0xd8>
      otg_epin_handler(usbp, 6);
 8001d4c:	2006      	movs	r0, #6
 8001d4e:	f7ff fdf7 	bl	8001940 <otg_epin_handler.constprop.0>
 8001d52:	e6e6      	b.n	8001b22 <Vector1D4+0xd2>
      otg_epin_handler(usbp, 5);
 8001d54:	2005      	movs	r0, #5
 8001d56:	f7ff fdf3 	bl	8001940 <otg_epin_handler.constprop.0>
 8001d5a:	e6df      	b.n	8001b1c <Vector1D4+0xcc>
      otg_epin_handler(usbp, 4);
 8001d5c:	2004      	movs	r0, #4
 8001d5e:	f7ff fdef 	bl	8001940 <otg_epin_handler.constprop.0>
 8001d62:	e6d8      	b.n	8001b16 <Vector1D4+0xc6>
      otg_epin_handler(usbp, 3);
 8001d64:	2003      	movs	r0, #3
 8001d66:	f7ff fdeb 	bl	8001940 <otg_epin_handler.constprop.0>
 8001d6a:	e6d1      	b.n	8001b10 <Vector1D4+0xc0>
      otg_epin_handler(usbp, 2);
 8001d6c:	2002      	movs	r0, #2
 8001d6e:	f7ff fde7 	bl	8001940 <otg_epin_handler.constprop.0>
 8001d72:	e6ca      	b.n	8001b0a <Vector1D4+0xba>
      otg_epin_handler(usbp, 1);
 8001d74:	2001      	movs	r0, #1
 8001d76:	f7ff fde3 	bl	8001940 <otg_epin_handler.constprop.0>
 8001d7a:	e6c3      	b.n	8001b04 <Vector1D4+0xb4>
      otg_epin_handler(usbp, 0);
 8001d7c:	2000      	movs	r0, #0
 8001d7e:	f7ff fddf 	bl	8001940 <otg_epin_handler.constprop.0>
 8001d82:	e6bc      	b.n	8001afe <Vector1D4+0xae>
      otgp->GINTMSK &= ~GINTMSK_SOFM;
 8001d84:	69bb      	ldr	r3, [r7, #24]
 8001d86:	f023 0308 	bic.w	r3, r3, #8
 8001d8a:	61bb      	str	r3, [r7, #24]
    if (usbp->state == USB_SUSPENDED) {
 8001d8c:	7833      	ldrb	r3, [r6, #0]
 8001d8e:	2b05      	cmp	r3, #5
 8001d90:	f47f ae86 	bne.w	8001aa0 <Vector1D4+0x50>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8001d94:	f8d7 3e00 	ldr.w	r3, [r7, #3584]	; 0xe00
      _usb_wakeup(usbp);
 8001d98:	4630      	mov	r0, r6
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8001d9a:	f023 0303 	bic.w	r3, r3, #3
 8001d9e:	f8c7 3e00 	str.w	r3, [r7, #3584]	; 0xe00
      _usb_wakeup(usbp);
 8001da2:	f7fe fc95 	bl	80006d0 <_usb_wakeup>
    _usb_isr_invoke_sof_cb(usbp);
 8001da6:	6874      	ldr	r4, [r6, #4]
 8001da8:	e67a      	b.n	8001aa0 <Vector1D4+0x50>
    max = usbp->epc[ep]->out_state->rxsize - usbp->epc[ep]->out_state->rxcnt;
 8001daa:	1c98      	adds	r0, r3, #2
 8001dac:	eb06 0380 	add.w	r3, r6, r0, lsl #2
 8001db0:	685b      	ldr	r3, [r3, #4]
 8001db2:	f8d3 c018 	ldr.w	ip, [r3, #24]
 8001db6:	e9dc 4300 	ldrd	r4, r3, [ip]
 8001dba:	eba4 0e03 	sub.w	lr, r4, r3
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8001dbe:	f8dc 4008 	ldr.w	r4, [ip, #8]
  while (i < n) {
 8001dc2:	b1d2      	cbz	r2, 8001dfa <Vector1D4+0x3aa>
      w = *fifop;
 8001dc4:	f501 5c80 	add.w	ip, r1, #4096	; 0x1000
  size_t i = 0;
 8001dc8:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 8001dca:	f013 0f03 	tst.w	r3, #3
      *buf++ = (uint8_t)w;
 8001dce:	4621      	mov	r1, r4
    if ((i & 3) == 0) {
 8001dd0:	d101      	bne.n	8001dd6 <Vector1D4+0x386>
      w = *fifop;
 8001dd2:	f8dc 8000 	ldr.w	r8, [ip]
    if (i < max) {
 8001dd6:	459e      	cmp	lr, r3
    i++;
 8001dd8:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 8001ddc:	d904      	bls.n	8001de8 <Vector1D4+0x398>
      *buf++ = (uint8_t)w;
 8001dde:	f801 8b01 	strb.w	r8, [r1], #1
      w >>= 8;
 8001de2:	ea4f 2818 	mov.w	r8, r8, lsr #8
      *buf++ = (uint8_t)w;
 8001de6:	460c      	mov	r4, r1
  while (i < n) {
 8001de8:	429a      	cmp	r2, r3
 8001dea:	d1ee      	bne.n	8001dca <Vector1D4+0x37a>
      usbp->epc[ep]->out_state->rxbuf += n;
 8001dec:	eb06 0380 	add.w	r3, r6, r0, lsl #2
 8001df0:	685b      	ldr	r3, [r3, #4]
 8001df2:	f8d3 c018 	ldr.w	ip, [r3, #24]
      usbp->epc[ep]->out_state->rxcnt += n;
 8001df6:	e9dc 3401 	ldrd	r3, r4, [ip, #4]
    if (n < max) {
 8001dfa:	4572      	cmp	r2, lr
 8001dfc:	d204      	bcs.n	8001e08 <Vector1D4+0x3b8>
      usbp->epc[ep]->out_state->rxbuf += n;
 8001dfe:	4414      	add	r4, r2
      usbp->epc[ep]->out_state->rxcnt += n;
 8001e00:	441a      	add	r2, r3
 8001e02:	e9cc 2401 	strd	r2, r4, [ip, #4]
 8001e06:	e695      	b.n	8001b34 <Vector1D4+0xe4>
      usbp->epc[ep]->out_state->rxbuf += max;
 8001e08:	4474      	add	r4, lr
      usbp->epc[ep]->out_state->rxcnt += max;
 8001e0a:	4473      	add	r3, lr
 8001e0c:	e9cc 3401 	strd	r3, r4, [ip, #4]
 8001e10:	e690      	b.n	8001b34 <Vector1D4+0xe4>
    _usb_reset(usbp);
 8001e12:	4805      	ldr	r0, [pc, #20]	; (8001e28 <Vector1D4+0x3d8>)
 8001e14:	f7fe fc24 	bl	8000660 <_usb_reset>
  OSAL_IRQ_EPILOGUE();
 8001e18:	4804      	ldr	r0, [pc, #16]	; (8001e2c <Vector1D4+0x3dc>)
 8001e1a:	f000 fc91 	bl	8002740 <__trace_isr_leave>
}
 8001e1e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8001e22:	f000 be5d 	b.w	8002ae0 <__port_irq_epilogue>
 8001e26:	bf00      	nop
 8001e28:	24000100 	.word	0x24000100
 8001e2c:	08002dc0 	.word	0x08002dc0

08001e30 <usb_lld_stall_out>:
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001e30:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8001e34:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8001e38:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8001e3c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001e40:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8001e44:	4770      	bx	lr
 8001e46:	bf00      	nop
	...

08001e50 <usb_lld_stall_in>:
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001e50:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8001e54:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8001e58:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8001e5c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001e60:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
}
 8001e64:	4770      	bx	lr
 8001e66:	bf00      	nop
	...

08001e70 <usb_lld_clear_out>:
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8001e70:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8001e74:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8001e78:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8001e7c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8001e80:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8001e84:	4770      	bx	lr
 8001e86:	bf00      	nop
	...

08001e90 <usb_lld_clear_in>:
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8001e90:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 8001e94:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8001e98:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8001e9c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8001ea0:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
}
 8001ea4:	4770      	bx	lr
 8001ea6:	bf00      	nop
	...

08001eb0 <sdc_lld_serve_interrupt>:
 8001eb0:	2330      	movs	r3, #48	; 0x30
/**
 * @brief   Shared service routine.
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 */
void sdc_lld_serve_interrupt(SDCDriver *sdcp) {
 8001eb2:	b510      	push	{r4, lr}
 8001eb4:	f383 8811 	msr	BASEPRI, r3

  osalSysLockFromISR();

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  sdcp->sdmmc->MASK = 0U;
 8001eb8:	2400      	movs	r4, #0
 8001eba:	6c43      	ldr	r3, [r0, #68]	; 0x44
  chThdResumeI(trp, msg);
 8001ebc:	3040      	adds	r0, #64	; 0x40
 8001ebe:	4621      	mov	r1, r4
 8001ec0:	63dc      	str	r4, [r3, #60]	; 0x3c
 8001ec2:	f000 fdad 	bl	8002a20 <chThdResumeI>
 8001ec6:	f384 8811 	msr	BASEPRI, r4
  osalThreadResumeI(&sdcp->thread, MSG_OK);

  osalSysUnlockFromISR();
}
 8001eca:	bd10      	pop	{r4, pc}
 8001ecc:	0000      	movs	r0, r0
	...

08001ed0 <spi_lld_configure.isra.0>:
/*===========================================================================*/

static void spi_lld_configure(SPIDriver *spip) {

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0U;
 8001ed0:	2200      	movs	r2, #0
  spip->spi->CR2  = 0U;
  spip->spi->IER  = SPI_IER_OVRIE;
  spip->spi->IFCR = 0xFFFFFFFFU;
  spip->spi->CFG1 = (spip->config->cfg1 & ~SPI_CFG1_FTHLV_Msk) |
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 8001ed2:	4b12      	ldr	r3, [pc, #72]	; (8001f1c <spi_lld_configure.isra.0+0x4c>)
  spip->spi->CR1  = 0U;
 8001ed4:	600a      	str	r2, [r1, #0]
  spip->spi->CR2  = 0U;
 8001ed6:	604a      	str	r2, [r1, #4]
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 8001ed8:	6942      	ldr	r2, [r0, #20]
static void spi_lld_configure(SPIDriver *spip) {
 8001eda:	b410      	push	{r4}
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 8001edc:	4013      	ands	r3, r2
  spip->spi->IER  = SPI_IER_OVRIE;
 8001ede:	2440      	movs	r4, #64	; 0x40
  if (spip->config->slave) {
 8001ee0:	7842      	ldrb	r2, [r0, #1]
  spip->spi->IER  = SPI_IER_OVRIE;
 8001ee2:	610c      	str	r4, [r1, #16]
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 8001ee4:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
  spip->spi->IFCR = 0xFFFFFFFFU;
 8001ee8:	f04f 34ff 	mov.w	r4, #4294967295
 8001eec:	618c      	str	r4, [r1, #24]
  spip->spi->CFG1 = (spip->config->cfg1 & ~SPI_CFG1_FTHLV_Msk) |
 8001eee:	608b      	str	r3, [r1, #8]
  if (spip->config->slave) {
 8001ef0:	b142      	cbz	r2, 8001f04 <spi_lld_configure.isra.0+0x34>
    spip->spi->CFG2 = spip->config->cfg2 & ~SPI_CFG2_COMM_Msk;
 8001ef2:	6983      	ldr	r3, [r0, #24]
  else {
    spip->spi->CFG2 = (spip->config->cfg2 | SPI_CFG2_MASTER | SPI_CFG2_SSOE) &
                      ~SPI_CFG2_COMM_Msk;
  }
  spip->spi->CR1  = SPI_CR1_MASRX | SPI_CR1_SPE;
}
 8001ef4:	bc10      	pop	{r4}
    spip->spi->CFG2 = spip->config->cfg2 & ~SPI_CFG2_COMM_Msk;
 8001ef6:	f423 23c0 	bic.w	r3, r3, #393216	; 0x60000
 8001efa:	60cb      	str	r3, [r1, #12]
  spip->spi->CR1  = SPI_CR1_MASRX | SPI_CR1_SPE;
 8001efc:	f240 1301 	movw	r3, #257	; 0x101
 8001f00:	600b      	str	r3, [r1, #0]
}
 8001f02:	4770      	bx	lr
    spip->spi->CFG2 = (spip->config->cfg2 | SPI_CFG2_MASTER | SPI_CFG2_SSOE) &
 8001f04:	6982      	ldr	r2, [r0, #24]
 8001f06:	4b06      	ldr	r3, [pc, #24]	; (8001f20 <spi_lld_configure.isra.0+0x50>)
}
 8001f08:	bc10      	pop	{r4}
    spip->spi->CFG2 = (spip->config->cfg2 | SPI_CFG2_MASTER | SPI_CFG2_SSOE) &
 8001f0a:	4013      	ands	r3, r2
 8001f0c:	f043 5301 	orr.w	r3, r3, #541065216	; 0x20400000
 8001f10:	60cb      	str	r3, [r1, #12]
  spip->spi->CR1  = SPI_CR1_MASRX | SPI_CR1_SPE;
 8001f12:	f240 1301 	movw	r3, #257	; 0x101
 8001f16:	600b      	str	r3, [r1, #0]
}
 8001f18:	4770      	bx	lr
 8001f1a:	bf00      	nop
 8001f1c:	ffff3e1f 	.word	0xffff3e1f
 8001f20:	dfb9ffff 	.word	0xdfb9ffff
	...

08001f30 <spi_lld_stop_abort>:
 */
static void spi_lld_stop_abort(SPIDriver *spip) {

  /* Stopping DMAs and waiting for FIFOs to be empty.*/
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  if (spip->is_bdma)
 8001f30:	f890 3020 	ldrb.w	r3, [r0, #32]
static void spi_lld_stop_abort(SPIDriver *spip) {
 8001f34:	b410      	push	{r4}
  if (spip->is_bdma)
 8001f36:	2b00      	cmp	r3, #0
 8001f38:	d034      	beq.n	8001fa4 <spi_lld_stop_abort+0x74>
#endif
#if defined(STM32_SPI_BDMA_REQUIRED)
  {
    bdmaStreamDisable(spip->tx.bdma);
 8001f3a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001f3c:	e9d3 4100 	ldrd	r4, r1, [r3]
 8001f40:	680a      	ldr	r2, [r1, #0]
 8001f42:	f022 020f 	bic.w	r2, r2, #15
 8001f46:	600a      	str	r2, [r1, #0]
 8001f48:	7a19      	ldrb	r1, [r3, #8]
 8001f4a:	230e      	movs	r3, #14
    bdmaStreamDisable(spip->rx.bdma);
 8001f4c:	6a42      	ldr	r2, [r0, #36]	; 0x24
    bdmaStreamDisable(spip->tx.bdma);
 8001f4e:	fa03 f101 	lsl.w	r1, r3, r1
 8001f52:	6061      	str	r1, [r4, #4]
    bdmaStreamDisable(spip->rx.bdma);
 8001f54:	6854      	ldr	r4, [r2, #4]
 8001f56:	6821      	ldr	r1, [r4, #0]
 8001f58:	f021 010f 	bic.w	r1, r1, #15
 8001f5c:	6021      	str	r1, [r4, #0]
 8001f5e:	7a11      	ldrb	r1, [r2, #8]
 8001f60:	6812      	ldr	r2, [r2, #0]
 8001f62:	408b      	lsls	r3, r1
 8001f64:	6053      	str	r3, [r2, #4]
     in a clean state.*/
  if (false) {
  }

#if STM32_SPI_USE_SPI1
  else if (&SPID1 == spip) {
 8001f66:	4b47      	ldr	r3, [pc, #284]	; (8002084 <spi_lld_stop_abort+0x154>)
 8001f68:	4298      	cmp	r0, r3
 8001f6a:	d03a      	beq.n	8001fe2 <spi_lld_stop_abort+0xb2>
    rccResetSPI1();
  }
#endif

#if STM32_SPI_USE_SPI2
  else if (&SPID2 == spip) {
 8001f6c:	4b46      	ldr	r3, [pc, #280]	; (8002088 <spi_lld_stop_abort+0x158>)
 8001f6e:	4298      	cmp	r0, r3
 8001f70:	d04b      	beq.n	800200a <spi_lld_stop_abort+0xda>
    rccResetSPI2();
  }
#endif

#if STM32_SPI_USE_SPI3
  else if (&SPID3 == spip) {
 8001f72:	4b46      	ldr	r3, [pc, #280]	; (800208c <spi_lld_stop_abort+0x15c>)
 8001f74:	4298      	cmp	r0, r3
 8001f76:	d05c      	beq.n	8002032 <spi_lld_stop_abort+0x102>
    rccResetSPI4();
  }
#endif

#if STM32_SPI_USE_SPI5
  else if (&SPID5 == spip) {
 8001f78:	4b45      	ldr	r3, [pc, #276]	; (8002090 <spi_lld_stop_abort+0x160>)
 8001f7a:	4298      	cmp	r0, r3
 8001f7c:	d06d      	beq.n	800205a <spi_lld_stop_abort+0x12a>
    rccResetSPI5();
  }
#endif

#if STM32_SPI_USE_SPI6
  else if (&SPID6 == spip) {
 8001f7e:	4b45      	ldr	r3, [pc, #276]	; (8002094 <spi_lld_stop_abort+0x164>)
 8001f80:	4298      	cmp	r0, r3
 8001f82:	d151      	bne.n	8002028 <spi_lld_stop_abort+0xf8>
  RCC->APB4RSTR |= mask;
 8001f84:	4b44      	ldr	r3, [pc, #272]	; (8002098 <spi_lld_stop_abort+0x168>)
 8001f86:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8001f8a:	f042 0220 	orr.w	r2, r2, #32
 8001f8e:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  RCC->APB4RSTR &= ~mask;
 8001f92:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8001f96:	f022 0220 	bic.w	r2, r2, #32
 8001f9a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  (void)RCC->APB4RSTR;
 8001f9e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
}
 8001fa2:	e041      	b.n	8002028 <spi_lld_stop_abort+0xf8>
    dmaStreamDisable(spip->tx.dma);
 8001fa4:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8001fa6:	6822      	ldr	r2, [r4, #0]
 8001fa8:	6813      	ldr	r3, [r2, #0]
 8001faa:	f023 031f 	bic.w	r3, r3, #31
 8001fae:	6013      	str	r3, [r2, #0]
 8001fb0:	6813      	ldr	r3, [r2, #0]
 8001fb2:	07d9      	lsls	r1, r3, #31
 8001fb4:	d4fc      	bmi.n	8001fb0 <spi_lld_stop_abort+0x80>
 8001fb6:	7b22      	ldrb	r2, [r4, #12]
 8001fb8:	233d      	movs	r3, #61	; 0x3d
    dmaStreamDisable(spip->rx.dma);
 8001fba:	6a41      	ldr	r1, [r0, #36]	; 0x24
    dmaStreamDisable(spip->tx.dma);
 8001fbc:	4093      	lsls	r3, r2
 8001fbe:	6864      	ldr	r4, [r4, #4]
    dmaStreamDisable(spip->rx.dma);
 8001fc0:	680a      	ldr	r2, [r1, #0]
    dmaStreamDisable(spip->tx.dma);
 8001fc2:	6023      	str	r3, [r4, #0]
    dmaStreamDisable(spip->rx.dma);
 8001fc4:	6813      	ldr	r3, [r2, #0]
 8001fc6:	f023 031f 	bic.w	r3, r3, #31
 8001fca:	6013      	str	r3, [r2, #0]
 8001fcc:	6813      	ldr	r3, [r2, #0]
 8001fce:	07db      	lsls	r3, r3, #31
 8001fd0:	d4fc      	bmi.n	8001fcc <spi_lld_stop_abort+0x9c>
 8001fd2:	7b0c      	ldrb	r4, [r1, #12]
 8001fd4:	233d      	movs	r3, #61	; 0x3d
 8001fd6:	684a      	ldr	r2, [r1, #4]
 8001fd8:	40a3      	lsls	r3, r4
 8001fda:	6013      	str	r3, [r2, #0]
  else if (&SPID1 == spip) {
 8001fdc:	4b29      	ldr	r3, [pc, #164]	; (8002084 <spi_lld_stop_abort+0x154>)
 8001fde:	4298      	cmp	r0, r3
 8001fe0:	d1c4      	bne.n	8001f6c <spi_lld_stop_abort+0x3c>
  RCC->APB2RSTR |= mask;
 8001fe2:	4b2d      	ldr	r3, [pc, #180]	; (8002098 <spi_lld_stop_abort+0x168>)
  else {
    osalDbgAssert(false, "invalid SPI instance");
  }

  /* Reconfiguring SPI.*/
  spi_lld_configure(spip);
 8001fe4:	69c1      	ldr	r1, [r0, #28]
 8001fe6:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8001fea:	6840      	ldr	r0, [r0, #4]
 8001fec:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
}
 8001ff0:	bc10      	pop	{r4}
 8001ff2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8001ff6:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8001ffa:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001ffe:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8002002:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  spi_lld_configure(spip);
 8002006:	f7ff bf63 	b.w	8001ed0 <spi_lld_configure.isra.0>
  RCC->APB1LRSTR |= mask;
 800200a:	4b23      	ldr	r3, [pc, #140]	; (8002098 <spi_lld_stop_abort+0x168>)
 800200c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8002010:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002014:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 8002018:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800201c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8002020:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8002024:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002028:	69c1      	ldr	r1, [r0, #28]
}
 800202a:	bc10      	pop	{r4}
  spi_lld_configure(spip);
 800202c:	6840      	ldr	r0, [r0, #4]
 800202e:	f7ff bf4f 	b.w	8001ed0 <spi_lld_configure.isra.0>
  RCC->APB1LRSTR |= mask;
 8002032:	4b19      	ldr	r3, [pc, #100]	; (8002098 <spi_lld_stop_abort+0x168>)
 8002034:	69c1      	ldr	r1, [r0, #28]
 8002036:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800203a:	6840      	ldr	r0, [r0, #4]
 800203c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
}
 8002040:	bc10      	pop	{r4}
 8002042:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 8002046:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800204a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800204e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8002052:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  spi_lld_configure(spip);
 8002056:	f7ff bf3b 	b.w	8001ed0 <spi_lld_configure.isra.0>
  RCC->APB2RSTR |= mask;
 800205a:	4b0f      	ldr	r3, [pc, #60]	; (8002098 <spi_lld_stop_abort+0x168>)
 800205c:	69c1      	ldr	r1, [r0, #28]
 800205e:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8002062:	6840      	ldr	r0, [r0, #4]
 8002064:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
}
 8002068:	bc10      	pop	{r4}
 800206a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 800206e:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8002072:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8002076:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 800207a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  spi_lld_configure(spip);
 800207e:	f7ff bf27 	b.w	8001ed0 <spi_lld_configure.isra.0>
 8002082:	bf00      	nop
 8002084:	24000204 	.word	0x24000204
 8002088:	24000240 	.word	0x24000240
 800208c:	2400027c 	.word	0x2400027c
 8002090:	240002b8 	.word	0x240002b8
 8002094:	240002f4 	.word	0x240002f4
 8002098:	58024400 	.word	0x58024400
 800209c:	00000000 	.word	0x00000000

080020a0 <VectorCC>:
/**
 * @brief   SPI1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI1_HANDLER) {
 80020a0:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 80020a2:	4c16      	ldr	r4, [pc, #88]	; (80020fc <VectorCC+0x5c>)

  OSAL_IRQ_PROLOGUE();
 80020a4:	4816      	ldr	r0, [pc, #88]	; (8002100 <VectorCC+0x60>)
 80020a6:	f000 fb33 	bl	8002710 <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 80020aa:	69e2      	ldr	r2, [r4, #28]
 80020ac:	6953      	ldr	r3, [r2, #20]
 80020ae:	6911      	ldr	r1, [r2, #16]
 80020b0:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 80020b2:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 80020b4:	065b      	lsls	r3, r3, #25
 80020b6:	d406      	bmi.n	80020c6 <VectorCC+0x26>

  spi_lld_serve_interrupt(&SPID1);

  OSAL_IRQ_EPILOGUE();
 80020b8:	4811      	ldr	r0, [pc, #68]	; (8002100 <VectorCC+0x60>)
 80020ba:	f000 fb41 	bl	8002740 <__trace_isr_leave>
}
 80020be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80020c2:	f000 bd0d 	b.w	8002ae0 <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 80020c6:	4620      	mov	r0, r4
 80020c8:	f7ff ff32 	bl	8001f30 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 80020cc:	6863      	ldr	r3, [r4, #4]
 80020ce:	689b      	ldr	r3, [r3, #8]
 80020d0:	b10b      	cbz	r3, 80020d6 <VectorCC+0x36>
 80020d2:	4620      	mov	r0, r4
 80020d4:	4798      	blx	r3
 80020d6:	2330      	movs	r3, #48	; 0x30
 80020d8:	f383 8811 	msr	BASEPRI, r3
 80020dc:	f06f 0112 	mvn.w	r1, #18
 80020e0:	4808      	ldr	r0, [pc, #32]	; (8002104 <VectorCC+0x64>)
 80020e2:	f000 fc9d 	bl	8002a20 <chThdResumeI>
 80020e6:	2300      	movs	r3, #0
 80020e8:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 80020ec:	4804      	ldr	r0, [pc, #16]	; (8002100 <VectorCC+0x60>)
 80020ee:	f000 fb27 	bl	8002740 <__trace_isr_leave>
}
 80020f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80020f6:	f000 bcf3 	b.w	8002ae0 <__port_irq_epilogue>
 80020fa:	bf00      	nop
 80020fc:	24000204 	.word	0x24000204
 8002100:	08002e20 	.word	0x08002e20
 8002104:	2400020c 	.word	0x2400020c
	...

08002110 <VectorD0>:
/**
 * @brief   SPI2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI2_HANDLER) {
 8002110:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8002112:	4c16      	ldr	r4, [pc, #88]	; (800216c <VectorD0+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8002114:	4816      	ldr	r0, [pc, #88]	; (8002170 <VectorD0+0x60>)
 8002116:	f000 fafb 	bl	8002710 <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 800211a:	69e2      	ldr	r2, [r4, #28]
 800211c:	6953      	ldr	r3, [r2, #20]
 800211e:	6911      	ldr	r1, [r2, #16]
 8002120:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8002122:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8002124:	065b      	lsls	r3, r3, #25
 8002126:	d406      	bmi.n	8002136 <VectorD0+0x26>

  spi_lld_serve_interrupt(&SPID2);

  OSAL_IRQ_EPILOGUE();
 8002128:	4811      	ldr	r0, [pc, #68]	; (8002170 <VectorD0+0x60>)
 800212a:	f000 fb09 	bl	8002740 <__trace_isr_leave>
}
 800212e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002132:	f000 bcd5 	b.w	8002ae0 <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8002136:	4620      	mov	r0, r4
 8002138:	f7ff fefa 	bl	8001f30 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 800213c:	6863      	ldr	r3, [r4, #4]
 800213e:	689b      	ldr	r3, [r3, #8]
 8002140:	b10b      	cbz	r3, 8002146 <VectorD0+0x36>
 8002142:	4620      	mov	r0, r4
 8002144:	4798      	blx	r3
 8002146:	2330      	movs	r3, #48	; 0x30
 8002148:	f383 8811 	msr	BASEPRI, r3
 800214c:	f06f 0112 	mvn.w	r1, #18
 8002150:	4808      	ldr	r0, [pc, #32]	; (8002174 <VectorD0+0x64>)
 8002152:	f000 fc65 	bl	8002a20 <chThdResumeI>
 8002156:	2300      	movs	r3, #0
 8002158:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 800215c:	4804      	ldr	r0, [pc, #16]	; (8002170 <VectorD0+0x60>)
 800215e:	f000 faef 	bl	8002740 <__trace_isr_leave>
}
 8002162:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002166:	f000 bcbb 	b.w	8002ae0 <__port_irq_epilogue>
 800216a:	bf00      	nop
 800216c:	24000240 	.word	0x24000240
 8002170:	08002e14 	.word	0x08002e14
 8002174:	24000248 	.word	0x24000248
	...

08002180 <Vector10C>:
/**
 * @brief   SPI3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI3_HANDLER) {
 8002180:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8002182:	4c16      	ldr	r4, [pc, #88]	; (80021dc <Vector10C+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8002184:	4816      	ldr	r0, [pc, #88]	; (80021e0 <Vector10C+0x60>)
 8002186:	f000 fac3 	bl	8002710 <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 800218a:	69e2      	ldr	r2, [r4, #28]
 800218c:	6953      	ldr	r3, [r2, #20]
 800218e:	6911      	ldr	r1, [r2, #16]
 8002190:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8002192:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8002194:	065b      	lsls	r3, r3, #25
 8002196:	d406      	bmi.n	80021a6 <Vector10C+0x26>

  spi_lld_serve_interrupt(&SPID3);

  OSAL_IRQ_EPILOGUE();
 8002198:	4811      	ldr	r0, [pc, #68]	; (80021e0 <Vector10C+0x60>)
 800219a:	f000 fad1 	bl	8002740 <__trace_isr_leave>
}
 800219e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80021a2:	f000 bc9d 	b.w	8002ae0 <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 80021a6:	4620      	mov	r0, r4
 80021a8:	f7ff fec2 	bl	8001f30 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 80021ac:	6863      	ldr	r3, [r4, #4]
 80021ae:	689b      	ldr	r3, [r3, #8]
 80021b0:	b10b      	cbz	r3, 80021b6 <Vector10C+0x36>
 80021b2:	4620      	mov	r0, r4
 80021b4:	4798      	blx	r3
 80021b6:	2330      	movs	r3, #48	; 0x30
 80021b8:	f383 8811 	msr	BASEPRI, r3
 80021bc:	f06f 0112 	mvn.w	r1, #18
 80021c0:	4808      	ldr	r0, [pc, #32]	; (80021e4 <Vector10C+0x64>)
 80021c2:	f000 fc2d 	bl	8002a20 <chThdResumeI>
 80021c6:	2300      	movs	r3, #0
 80021c8:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 80021cc:	4804      	ldr	r0, [pc, #16]	; (80021e0 <Vector10C+0x60>)
 80021ce:	f000 fab7 	bl	8002740 <__trace_isr_leave>
}
 80021d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80021d6:	f000 bc83 	b.w	8002ae0 <__port_irq_epilogue>
 80021da:	bf00      	nop
 80021dc:	2400027c 	.word	0x2400027c
 80021e0:	08002e08 	.word	0x08002e08
 80021e4:	24000284 	.word	0x24000284
	...

080021f0 <Vector194>:
/**
 * @brief   SPI5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI5_HANDLER) {
 80021f0:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 80021f2:	4c16      	ldr	r4, [pc, #88]	; (800224c <Vector194+0x5c>)

  OSAL_IRQ_PROLOGUE();
 80021f4:	4816      	ldr	r0, [pc, #88]	; (8002250 <Vector194+0x60>)
 80021f6:	f000 fa8b 	bl	8002710 <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 80021fa:	69e2      	ldr	r2, [r4, #28]
 80021fc:	6953      	ldr	r3, [r2, #20]
 80021fe:	6911      	ldr	r1, [r2, #16]
 8002200:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8002202:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8002204:	065b      	lsls	r3, r3, #25
 8002206:	d406      	bmi.n	8002216 <Vector194+0x26>

  spi_lld_serve_interrupt(&SPID5);

  OSAL_IRQ_EPILOGUE();
 8002208:	4811      	ldr	r0, [pc, #68]	; (8002250 <Vector194+0x60>)
 800220a:	f000 fa99 	bl	8002740 <__trace_isr_leave>
}
 800220e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002212:	f000 bc65 	b.w	8002ae0 <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8002216:	4620      	mov	r0, r4
 8002218:	f7ff fe8a 	bl	8001f30 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 800221c:	6863      	ldr	r3, [r4, #4]
 800221e:	689b      	ldr	r3, [r3, #8]
 8002220:	b10b      	cbz	r3, 8002226 <Vector194+0x36>
 8002222:	4620      	mov	r0, r4
 8002224:	4798      	blx	r3
 8002226:	2330      	movs	r3, #48	; 0x30
 8002228:	f383 8811 	msr	BASEPRI, r3
 800222c:	f06f 0112 	mvn.w	r1, #18
 8002230:	4808      	ldr	r0, [pc, #32]	; (8002254 <Vector194+0x64>)
 8002232:	f000 fbf5 	bl	8002a20 <chThdResumeI>
 8002236:	2300      	movs	r3, #0
 8002238:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 800223c:	4804      	ldr	r0, [pc, #16]	; (8002250 <Vector194+0x60>)
 800223e:	f000 fa7f 	bl	8002740 <__trace_isr_leave>
}
 8002242:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002246:	f000 bc4b 	b.w	8002ae0 <__port_irq_epilogue>
 800224a:	bf00      	nop
 800224c:	240002b8 	.word	0x240002b8
 8002250:	08002dfc 	.word	0x08002dfc
 8002254:	240002c0 	.word	0x240002c0
	...

08002260 <Vector198>:
/**
 * @brief   SPI6 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI6_HANDLER) {
 8002260:	b510      	push	{r4, lr}
  sr = spip->spi->SR & spip->spi->IER;
 8002262:	4c16      	ldr	r4, [pc, #88]	; (80022bc <Vector198+0x5c>)

  OSAL_IRQ_PROLOGUE();
 8002264:	4816      	ldr	r0, [pc, #88]	; (80022c0 <Vector198+0x60>)
 8002266:	f000 fa53 	bl	8002710 <__trace_isr_enter>
  sr = spip->spi->SR & spip->spi->IER;
 800226a:	69e2      	ldr	r2, [r4, #28]
 800226c:	6953      	ldr	r3, [r2, #20]
 800226e:	6911      	ldr	r1, [r2, #16]
 8002270:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8002272:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8002274:	065b      	lsls	r3, r3, #25
 8002276:	d406      	bmi.n	8002286 <Vector198+0x26>

  spi_lld_serve_interrupt(&SPID6);

  OSAL_IRQ_EPILOGUE();
 8002278:	4811      	ldr	r0, [pc, #68]	; (80022c0 <Vector198+0x60>)
 800227a:	f000 fa61 	bl	8002740 <__trace_isr_leave>
}
 800227e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8002282:	f000 bc2d 	b.w	8002ae0 <__port_irq_epilogue>
    spi_lld_stop_abort(spip);
 8002286:	4620      	mov	r0, r4
 8002288:	f7ff fe52 	bl	8001f30 <spi_lld_stop_abort>
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 800228c:	6863      	ldr	r3, [r4, #4]
 800228e:	689b      	ldr	r3, [r3, #8]
 8002290:	b10b      	cbz	r3, 8002296 <Vector198+0x36>
 8002292:	4620      	mov	r0, r4
 8002294:	4798      	blx	r3
 8002296:	2330      	movs	r3, #48	; 0x30
 8002298:	f383 8811 	msr	BASEPRI, r3
 800229c:	f06f 0112 	mvn.w	r1, #18
 80022a0:	4808      	ldr	r0, [pc, #32]	; (80022c4 <Vector198+0x64>)
 80022a2:	f000 fbbd 	bl	8002a20 <chThdResumeI>
 80022a6:	2300      	movs	r3, #0
 80022a8:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 80022ac:	4804      	ldr	r0, [pc, #16]	; (80022c0 <Vector198+0x60>)
 80022ae:	f000 fa47 	bl	8002740 <__trace_isr_leave>
}
 80022b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80022b6:	f000 bc13 	b.w	8002ae0 <__port_irq_epilogue>
 80022ba:	bf00      	nop
 80022bc:	240002f4 	.word	0x240002f4
 80022c0:	08002df0 	.word	0x08002df0
 80022c4:	240002fc 	.word	0x240002fc
	...

080022d0 <st_lld_serve_interrupt>:
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 80022d0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
void st_lld_serve_interrupt(void) {
 80022d4:	b508      	push	{r3, lr}
  sr  = timp->SR;
 80022d6:	6911      	ldr	r1, [r2, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 80022d8:	68d3      	ldr	r3, [r2, #12]
 80022da:	400b      	ands	r3, r1
 80022dc:	b2d9      	uxtb	r1, r3
  timp->SR = ~sr;

  if ((sr & TIM_SR_CC1IF) != 0U)
 80022de:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 80022e0:	ea6f 0101 	mvn.w	r1, r1
 80022e4:	6111      	str	r1, [r2, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 80022e6:	d400      	bmi.n	80022ea <st_lld_serve_interrupt+0x1a>
      st_callbacks[3](3U);
    }
  }
#endif
#endif
}
 80022e8:	bd08      	pop	{r3, pc}
 80022ea:	2330      	movs	r3, #48	; 0x30
 80022ec:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 80022f0:	f000 f99e 	bl	8002630 <chSysTimerHandlerI>
 80022f4:	2300      	movs	r3, #0
 80022f6:	f383 8811 	msr	BASEPRI, r3
 80022fa:	bd08      	pop	{r3, pc}
 80022fc:	0000      	movs	r0, r0
	...

08002300 <sd_lld_serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 8002300:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 8002304:	6d45      	ldr	r5, [r0, #84]	; 0x54
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 8002306:	4606      	mov	r6, r0
  uint32_t cr1;
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8002308:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800230a:	0722      	lsls	r2, r4, #28
  u->ICR = isr;
 800230c:	622c      	str	r4, [r5, #32]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800230e:	d156      	bne.n	80023be <sd_lld_serve_interrupt+0xbe>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8002310:	05e2      	lsls	r2, r4, #23
 8002312:	d448      	bmi.n	80023a6 <sd_lld_serve_interrupt+0xa6>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 8002314:	06a0      	lsls	r0, r4, #26
 8002316:	d510      	bpl.n	800233a <sd_lld_serve_interrupt+0x3a>
 8002318:	f04f 0830 	mov.w	r8, #48	; 0x30
 800231c:	2700      	movs	r7, #0
 800231e:	f388 8811 	msr	BASEPRI, r8
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8002322:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002324:	4630      	mov	r0, r6
 8002326:	f896 105c 	ldrb.w	r1, [r6, #92]	; 0x5c
 800232a:	4019      	ands	r1, r3
 800232c:	f7fe f978 	bl	8000620 <sdIncomingDataI>
 8002330:	f387 8811 	msr	BASEPRI, r7
    osalSysUnlockFromISR();

    isr = u->ISR;
 8002334:	69ec      	ldr	r4, [r5, #28]
  while (isr & USART_ISR_RXNE) {
 8002336:	06a3      	lsls	r3, r4, #26
 8002338:	d4f1      	bmi.n	800231e <sd_lld_serve_interrupt+0x1e>
  }

  /* Caching CR1.*/
  cr1 = u->CR1;
 800233a:	f8d5 a000 	ldr.w	sl, [r5]
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
 800233e:	f01a 0f80 	tst.w	sl, #128	; 0x80
 8002342:	d01d      	beq.n	8002380 <sd_lld_serve_interrupt+0x80>
    while (isr & USART_ISR_TXE) {
 8002344:	0621      	lsls	r1, r4, #24
 8002346:	d51b      	bpl.n	8002380 <sd_lld_serve_interrupt+0x80>
      msg_t b;

      osalSysLockFromISR();
      b = oqGetI(&sdp->oqueue);
 8002348:	f106 0830 	add.w	r8, r6, #48	; 0x30
 800234c:	2730      	movs	r7, #48	; 0x30
 800234e:	f04f 0900 	mov.w	r9, #0
 8002352:	e005      	b.n	8002360 <sd_lld_serve_interrupt+0x60>
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        cr1 &= ~USART_CR1_TXEIE;
        osalSysUnlockFromISR();
        break;
      }
      u->TDR = b;
 8002354:	62a8      	str	r0, [r5, #40]	; 0x28
 8002356:	f389 8811 	msr	BASEPRI, r9
      osalSysUnlockFromISR();

      isr = u->ISR;
 800235a:	69ec      	ldr	r4, [r5, #28]
    while (isr & USART_ISR_TXE) {
 800235c:	0622      	lsls	r2, r4, #24
 800235e:	d50f      	bpl.n	8002380 <sd_lld_serve_interrupt+0x80>
 8002360:	f387 8811 	msr	BASEPRI, r7
      b = oqGetI(&sdp->oqueue);
 8002364:	4640      	mov	r0, r8
 8002366:	f7fe f93b 	bl	80005e0 <oqGetI>
      if (b < MSG_OK) {
 800236a:	2800      	cmp	r0, #0
 800236c:	daf2      	bge.n	8002354 <sd_lld_serve_interrupt+0x54>
  chEvtBroadcastFlagsI(esp, flags);
 800236e:	2108      	movs	r1, #8
 8002370:	1d30      	adds	r0, r6, #4
 8002372:	f000 fb75 	bl	8002a60 <chEvtBroadcastFlagsI>
        cr1 &= ~USART_CR1_TXEIE;
 8002376:	f02a 0a80 	bic.w	sl, sl, #128	; 0x80
 800237a:	2300      	movs	r3, #0
 800237c:	f383 8811 	msr	BASEPRI, r3
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 8002380:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8002384:	d00b      	beq.n	800239e <sd_lld_serve_interrupt+0x9e>
 8002386:	0663      	lsls	r3, r4, #25
 8002388:	d509      	bpl.n	800239e <sd_lld_serve_interrupt+0x9e>
 800238a:	2330      	movs	r3, #48	; 0x30
 800238c:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
 8002390:	e9d6 2311 	ldrd	r2, r3, [r6, #68]	; 0x44
 8002394:	429a      	cmp	r2, r3
 8002396:	d02d      	beq.n	80023f4 <sd_lld_serve_interrupt+0xf4>
 8002398:	2300      	movs	r3, #0
 800239a:	f383 8811 	msr	BASEPRI, r3
    }
    osalSysUnlockFromISR();
  }

  /* Writing CR1 once.*/
  u->CR1 = cr1;
 800239e:	f8c5 a000 	str.w	sl, [r5]
}
 80023a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80023a6:	2330      	movs	r3, #48	; 0x30
 80023a8:	f383 8811 	msr	BASEPRI, r3
 80023ac:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80023b0:	1d30      	adds	r0, r6, #4
 80023b2:	f000 fb55 	bl	8002a60 <chEvtBroadcastFlagsI>
 80023b6:	2300      	movs	r3, #0
 80023b8:	f383 8811 	msr	BASEPRI, r3
}
 80023bc:	e7aa      	b.n	8002314 <sd_lld_serve_interrupt+0x14>
  if (isr & USART_ISR_ORE)
 80023be:	f3c4 01c0 	ubfx	r1, r4, #3, #1
  if (isr & USART_ISR_PE)
 80023c2:	07e3      	lsls	r3, r4, #31
 80023c4:	f04f 0330 	mov.w	r3, #48	; 0x30
  if (isr & USART_ISR_ORE)
 80023c8:	ea4f 2101 	mov.w	r1, r1, lsl #8
    sts |= SD_PARITY_ERROR;
 80023cc:	bf48      	it	mi
 80023ce:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
 80023d2:	07a7      	lsls	r7, r4, #30
    sts |= SD_FRAMING_ERROR;
 80023d4:	bf48      	it	mi
 80023d6:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
 80023da:	0760      	lsls	r0, r4, #29
    sts |= SD_NOISE_ERROR;
 80023dc:	bf48      	it	mi
 80023de:	f041 0180 	orrmi.w	r1, r1, #128	; 0x80
 80023e2:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 80023e6:	1d30      	adds	r0, r6, #4
 80023e8:	f000 fb3a 	bl	8002a60 <chEvtBroadcastFlagsI>
 80023ec:	2300      	movs	r3, #0
 80023ee:	f383 8811 	msr	BASEPRI, r3
}
 80023f2:	e78d      	b.n	8002310 <sd_lld_serve_interrupt+0x10>
    if (oqIsEmptyI(&sdp->oqueue)) {
 80023f4:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 80023f6:	2b00      	cmp	r3, #0
 80023f8:	d0ce      	beq.n	8002398 <sd_lld_serve_interrupt+0x98>
 80023fa:	2110      	movs	r1, #16
 80023fc:	1d30      	adds	r0, r6, #4
      cr1 &= ~USART_CR1_TCIE;
 80023fe:	f02a 0a40 	bic.w	sl, sl, #64	; 0x40
 8002402:	f000 fb2d 	bl	8002a60 <chEvtBroadcastFlagsI>
 8002406:	e7c7      	b.n	8002398 <sd_lld_serve_interrupt+0x98>
	...

08002410 <__early_init>:
  RCC->AHB4RSTR |= mask;
 8002410:	4a66      	ldr	r2, [pc, #408]	; (80025ac <__early_init+0x19c>)
 8002412:	f240 70ff 	movw	r0, #2047	; 0x7ff
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002416:	2300      	movs	r3, #0
 8002418:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 800241c:	4301      	orrs	r1, r0
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 800241e:	b470      	push	{r4, r5, r6}
 8002420:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88
  RCC->AHB4RSTR &= ~mask;
 8002424:	4c62      	ldr	r4, [pc, #392]	; (80025b0 <__early_init+0x1a0>)
 8002426:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
  gpiop->OSPEEDR = config->ospeedr;
 800242a:	4d62      	ldr	r5, [pc, #392]	; (80025b4 <__early_init+0x1a4>)
 800242c:	400c      	ands	r4, r1
  gpiop->OTYPER  = config->otyper;
 800242e:	4962      	ldr	r1, [pc, #392]	; (80025b8 <__early_init+0x1a8>)
  gpiop->AFRL    = config->afrl;
 8002430:	4e62      	ldr	r6, [pc, #392]	; (80025bc <__early_init+0x1ac>)
 8002432:	f8c2 4088 	str.w	r4, [r2, #136]	; 0x88
  (void)RCC->AHB4RSTR;
 8002436:	f8d2 4088 	ldr.w	r4, [r2, #136]	; 0x88
 */
__STATIC_INLINE void rccEnableAHB4(uint32_t mask, bool lp) {

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->AHB4ENR |= mask;
 800243a:	f8d2 40e0 	ldr.w	r4, [r2, #224]	; 0xe0
 800243e:	4304      	orrs	r4, r0
 8002440:	f8c2 40e0 	str.w	r4, [r2, #224]	; 0xe0
  if (lp) {
    RCC_C1->AHB4LPENR |= mask;
 8002444:	f8d2 4108 	ldr.w	r4, [r2, #264]	; 0x108
 8002448:	4304      	orrs	r4, r0
  gpiop->OTYPER  = config->otyper;
 800244a:	485d      	ldr	r0, [pc, #372]	; (80025c0 <__early_init+0x1b0>)
 800244c:	f8c2 4108 	str.w	r4, [r2, #264]	; 0x108
  gpiop->ODR     = config->odr;
 8002450:	f44f 44c0 	mov.w	r4, #24576	; 0x6000
  }
  else {
    RCC_C1->AHB4LPENR &= ~mask;
  }
  (void)RCC_C1->AHB4LPENR;
 8002454:	f8d2 2108 	ldr.w	r2, [r2, #264]	; 0x108
  gpiop->OTYPER  = config->otyper;
 8002458:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800245a:	608d      	str	r5, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 800245c:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 800245e:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002460:	240a      	movs	r4, #10
  gpiop->OTYPER  = config->otyper;
 8002462:	4a58      	ldr	r2, [pc, #352]	; (80025c4 <__early_init+0x1b4>)
  gpiop->AFRL    = config->afrl;
 8002464:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8002466:	4c58      	ldr	r4, [pc, #352]	; (80025c8 <__early_init+0x1b8>)
  gpiop->OSPEEDR = config->ospeedr;
 8002468:	4d58      	ldr	r5, [pc, #352]	; (80025cc <__early_init+0x1bc>)
  gpiop->AFRH    = config->afrh;
 800246a:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800246c:	4c58      	ldr	r4, [pc, #352]	; (80025d0 <__early_init+0x1c0>)
 800246e:	600c      	str	r4, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8002470:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
  gpiop->OSPEEDR = config->ospeedr;
 8002474:	4c57      	ldr	r4, [pc, #348]	; (80025d4 <__early_init+0x1c4>)
  gpiop->OTYPER  = config->otyper;
 8002476:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002478:	6084      	str	r4, [r0, #8]
  gpiop->ODR     = config->odr;
 800247a:	2480      	movs	r4, #128	; 0x80
  gpiop->PUPDR   = config->pupdr;
 800247c:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
 800247e:	6144      	str	r4, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8002480:	4c55      	ldr	r4, [pc, #340]	; (80025d8 <__early_init+0x1c8>)
 8002482:	6204      	str	r4, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8002484:	4c55      	ldr	r4, [pc, #340]	; (80025dc <__early_init+0x1cc>)
 8002486:	6244      	str	r4, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002488:	4c55      	ldr	r4, [pc, #340]	; (80025e0 <__early_init+0x1d0>)
 800248a:	6004      	str	r4, [r0, #0]
  gpiop->ODR     = config->odr;
 800248c:	2040      	movs	r0, #64	; 0x40
  gpiop->OSPEEDR = config->ospeedr;
 800248e:	4c55      	ldr	r4, [pc, #340]	; (80025e4 <__early_init+0x1d4>)
  gpiop->OTYPER  = config->otyper;
 8002490:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002492:	6094      	str	r4, [r2, #8]
  gpiop->AFRH    = config->afrh;
 8002494:	4c54      	ldr	r4, [pc, #336]	; (80025e8 <__early_init+0x1d8>)
  gpiop->PUPDR   = config->pupdr;
 8002496:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 8002498:	6153      	str	r3, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800249a:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 800249c:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800249e:	4c53      	ldr	r4, [pc, #332]	; (80025ec <__early_init+0x1dc>)
 80024a0:	6014      	str	r4, [r2, #0]
  gpiop->OTYPER  = config->otyper;
 80024a2:	f502 6200 	add.w	r2, r2, #2048	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
 80024a6:	4c52      	ldr	r4, [pc, #328]	; (80025f0 <__early_init+0x1e0>)
  gpiop->OTYPER  = config->otyper;
 80024a8:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80024aa:	608c      	str	r4, [r1, #8]
  gpiop->AFRL    = config->afrl;
 80024ac:	4c51      	ldr	r4, [pc, #324]	; (80025f4 <__early_init+0x1e4>)
  gpiop->PUPDR   = config->pupdr;
 80024ae:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 80024b0:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80024b2:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80024b4:	f104 44f8 	add.w	r4, r4, #2080374784	; 0x7c000000
 80024b8:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80024ba:	4c4f      	ldr	r4, [pc, #316]	; (80025f8 <__early_init+0x1e8>)
 80024bc:	600c      	str	r4, [r1, #0]
  gpiop->OSPEEDR = config->ospeedr;
 80024be:	4c4f      	ldr	r4, [pc, #316]	; (80025fc <__early_init+0x1ec>)
  gpiop->OTYPER  = config->otyper;
 80024c0:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80024c2:	6094      	str	r4, [r2, #8]
  gpiop->ODR     = config->odr;
 80024c4:	2404      	movs	r4, #4
  gpiop->PUPDR   = config->pupdr;
 80024c6:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 80024c8:	6154      	str	r4, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80024ca:	4c4d      	ldr	r4, [pc, #308]	; (8002600 <__early_init+0x1f0>)
 80024cc:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80024ce:	f04f 34cc 	mov.w	r4, #3435973836	; 0xcccccccc
 80024d2:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80024d4:	f104 445e 	add.w	r4, r4, #3724541952	; 0xde000000
 80024d8:	f5a4 1408 	sub.w	r4, r4, #2228224	; 0x220000
 80024dc:	f6a4 44f2 	subw	r4, r4, #3314	; 0xcf2
 80024e0:	6014      	str	r4, [r2, #0]
  gpiop->OTYPER  = config->otyper;
 80024e2:	f8c1 3804 	str.w	r3, [r1, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 80024e6:	f8c1 5808 	str.w	r5, [r1, #2056]	; 0x808
  gpiop->MODER   = config->moder;
 80024ea:	f46f 75d5 	mvn.w	r5, #426	; 0x1aa
  gpiop->PUPDR   = config->pupdr;
 80024ee:	f8c1 380c 	str.w	r3, [r1, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 80024f2:	f8c1 0814 	str.w	r0, [r1, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 80024f6:	4843      	ldr	r0, [pc, #268]	; (8002604 <__early_init+0x1f4>)
  gpiop->OTYPER  = config->otyper;
 80024f8:	4c43      	ldr	r4, [pc, #268]	; (8002608 <__early_init+0x1f8>)
  gpiop->AFRL    = config->afrl;
 80024fa:	f8c1 0820 	str.w	r0, [r1, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 80024fe:	f100 40f8 	add.w	r0, r0, #2080374784	; 0x7c000000
 8002502:	f6a0 4077 	subw	r0, r0, #3191	; 0xc77
 8002506:	f8c1 0824 	str.w	r0, [r1, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 800250a:	f1a0 5009 	sub.w	r0, r0, #574619648	; 0x22400000
 800250e:	f5a0 3009 	sub.w	r0, r0, #140288	; 0x22400
 8002512:	4428      	add	r0, r5
 8002514:	f04f 35ff 	mov.w	r5, #4294967295
 8002518:	f8c1 0800 	str.w	r0, [r1, #2048]	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
 800251c:	493b      	ldr	r1, [pc, #236]	; (800260c <__early_init+0x1fc>)
  gpiop->OTYPER  = config->otyper;
 800251e:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8002522:	f8c2 1808 	str.w	r1, [r2, #2056]	; 0x808
  gpiop->ODR     = config->odr;
 8002526:	f44f 6180 	mov.w	r1, #1024	; 0x400
  gpiop->PUPDR   = config->pupdr;
 800252a:	f8c2 380c 	str.w	r3, [r2, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 800252e:	f8c2 1814 	str.w	r1, [r2, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 8002532:	4937      	ldr	r1, [pc, #220]	; (8002610 <__early_init+0x200>)
  gpiop->OTYPER  = config->otyper;
 8002534:	4837      	ldr	r0, [pc, #220]	; (8002614 <__early_init+0x204>)
  gpiop->AFRL    = config->afrl;
 8002536:	f8c2 1820 	str.w	r1, [r2, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 800253a:	4937      	ldr	r1, [pc, #220]	; (8002618 <__early_init+0x208>)
 800253c:	f8c2 1824 	str.w	r1, [r2, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 8002540:	f1a1 51d5 	sub.w	r1, r1, #446693376	; 0x1aa00000
 8002544:	f5a1 11d4 	sub.w	r1, r1, #1736704	; 0x1a8000
 8002548:	f2a1 5172 	subw	r1, r1, #1394	; 0x572
 800254c:	f8c2 1800 	str.w	r1, [r2, #2048]	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
 8002550:	f44f 6243 	mov.w	r2, #3120	; 0xc30
  gpiop->OTYPER  = config->otyper;
 8002554:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002556:	60a2      	str	r2, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8002558:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 800255a:	6163      	str	r3, [r4, #20]
  gpiop->AFRL    = config->afrl;
 800255c:	6226      	str	r6, [r4, #32]
  gpiop->MODER   = config->moder;
 800255e:	f46f 6682 	mvn.w	r6, #1040	; 0x410
  gpiop->AFRH    = config->afrh;
 8002562:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002564:	6026      	str	r6, [r4, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8002566:	4c2d      	ldr	r4, [pc, #180]	; (800261c <__early_init+0x20c>)
  gpiop->OTYPER  = config->otyper;
 8002568:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800256a:	6084      	str	r4, [r0, #8]
  gpiop->AFRL    = config->afrl;
 800256c:	f1a4 44ab 	sub.w	r4, r4, #1434451968	; 0x55800000
  gpiop->PUPDR   = config->pupdr;
 8002570:	60c3      	str	r3, [r0, #12]
  gpiop->AFRL    = config->afrl;
 8002572:	f5a4 14dd 	sub.w	r4, r4, #1810432	; 0x1ba000
  gpiop->ODR     = config->odr;
 8002576:	6143      	str	r3, [r0, #20]
  gpiop->OTYPER  = config->otyper;
 8002578:	4929      	ldr	r1, [pc, #164]	; (8002620 <__early_init+0x210>)
  gpiop->AFRL    = config->afrl;
 800257a:	f6a4 747c 	subw	r4, r4, #3964	; 0xf7c
  gpiop->OTYPER  = config->otyper;
 800257e:	4a29      	ldr	r2, [pc, #164]	; (8002624 <__early_init+0x214>)
  gpiop->AFRL    = config->afrl;
 8002580:	6204      	str	r4, [r0, #32]
  gpiop->MODER   = config->moder;
 8002582:	4c29      	ldr	r4, [pc, #164]	; (8002628 <__early_init+0x218>)
  gpiop->AFRH    = config->afrh;
 8002584:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002586:	6004      	str	r4, [r0, #0]
  gpiop->OTYPER  = config->otyper;
 8002588:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800258a:	608b      	str	r3, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 800258c:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 800258e:	614b      	str	r3, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002590:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8002592:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002594:	600d      	str	r5, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8002596:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002598:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800259a:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 800259c:	6153      	str	r3, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800259e:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80025a0:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80025a2:	6015      	str	r5, [r2, #0]

  stm32_gpio_init();
  stm32_clock_init();
}
 80025a4:	bc70      	pop	{r4, r5, r6}
  stm32_clock_init();
 80025a6:	f7fe bb6b 	b.w	8000c80 <stm32_clock_init>
 80025aa:	bf00      	nop
 80025ac:	58024400 	.word	0x58024400
 80025b0:	fffff800 	.word	0xfffff800
 80025b4:	3ffd1417 	.word	0x3ffd1417
 80025b8:	58020000 	.word	0x58020000
 80025bc:	00c00c00 	.word	0x00c00c00
 80025c0:	58020400 	.word	0x58020400
 80025c4:	58020800 	.word	0x58020800
 80025c8:	000aa770 	.word	0x000aa770
 80025cc:	ffdfdfff 	.word	0xffdfdfff
 80025d0:	eaa8d7d6 	.word	0xeaa8d7d6
 80025d4:	ff004fc0 	.word	0xff004fc0
 80025d8:	00666000 	.word	0x00666000
 80025dc:	cc880000 	.word	0xcc880000
 80025e0:	aaff7abf 	.word	0xaaff7abf
 80025e4:	07ff0000 	.word	0x07ff0000
 80025e8:	000ccccc 	.word	0x000ccccc
 80025ec:	f2aaffff 	.word	0xf2aaffff
 80025f0:	f07fd03f 	.word	0xf07fd03f
 80025f4:	50000ccc 	.word	0x50000ccc
 80025f8:	af6a9fea 	.word	0xaf6a9fea
 80025fc:	ffffc01f 	.word	0xffffc01f
 8002600:	c00000cc 	.word	0xc00000cc
 8002604:	50cccccc 	.word	0x50cccccc
 8002608:	58021c00 	.word	0x58021c00
 800260c:	ffdf1f3f 	.word	0xffdf1f3f
 8002610:	00cc0ccc 	.word	0x00cc0ccc
 8002614:	58022000 	.word	0x58022000
 8002618:	c555505c 	.word	0xc555505c
 800261c:	0045ffcc 	.word	0x0045ffcc
 8002620:	58022400 	.word	0x58022400
 8002624:	58022800 	.word	0x58022800
 8002628:	ff71aabb 	.word	0xff71aabb
 800262c:	00000000 	.word	0x00000000

08002630 <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8002630:	f000 b8ce 	b.w	80027d0 <chVTDoTickI>
	...

08002640 <chSysPolledDelayX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002640:	4a03      	ldr	r2, [pc, #12]	; (8002650 <chSysPolledDelayX+0x10>)
 8002642:	6851      	ldr	r1, [r2, #4]
 8002644:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8002646:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8002648:	4298      	cmp	r0, r3
 800264a:	d8fb      	bhi.n	8002644 <chSysPolledDelayX+0x4>
  }
}
 800264c:	4770      	bx	lr
 800264e:	bf00      	nop
 8002650:	e0001000 	.word	0xe0001000
	...

08002660 <chRFCUCollectFaultsI>:
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8002660:	4a02      	ldr	r2, [pc, #8]	; (800266c <chRFCUCollectFaultsI+0xc>)
 8002662:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8002664:	4303      	orrs	r3, r0
 8002666:	6353      	str	r3, [r2, #52]	; 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8002668:	4770      	bx	lr
 800266a:	bf00      	nop
 800266c:	240003f0 	.word	0x240003f0

08002670 <trace_next.constprop.0>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {
 8002670:	b538      	push	{r3, r4, r5, lr}

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002672:	4c0c      	ldr	r4, [pc, #48]	; (80026a4 <trace_next.constprop.0+0x34>)
 8002674:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
 8002678:	f7fd ff72 	bl	8000560 <stGetCounter>
#if PORT_SUPPORTS_RT == TRUE
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800267c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8002680:	f504 6109 	add.w	r1, r4, #2192	; 0x890
 8002684:	4a08      	ldr	r2, [pc, #32]	; (80026a8 <trace_next.constprop.0+0x38>)
  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002686:	6068      	str	r0, [r5, #4]
 8002688:	6850      	ldr	r0, [r2, #4]
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800268a:	681a      	ldr	r2, [r3, #0]
 800268c:	f360 221f 	bfi	r2, r0, #8, #24
 8002690:	f843 2b10 	str.w	r2, [r3], #16
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8002694:	f104 0290 	add.w	r2, r4, #144	; 0x90
 8002698:	428b      	cmp	r3, r1
 800269a:	bf28      	it	cs
 800269c:	4613      	movcs	r3, r2
 800269e:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
  }
}
 80026a2:	bd38      	pop	{r3, r4, r5, pc}
 80026a4:	240003f0 	.word	0x240003f0
 80026a8:	e0001000 	.word	0xe0001000
 80026ac:	00000000 	.word	0x00000000

080026b0 <__trace_ready>:
 * @notapi
 */
void __trace_ready(thread_t *tp, msg_t msg) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 80026b0:	4b09      	ldr	r3, [pc, #36]	; (80026d8 <__trace_ready+0x28>)
 80026b2:	f8b3 2088 	ldrh.w	r2, [r3, #136]	; 0x88
 80026b6:	07d2      	lsls	r2, r2, #31
 80026b8:	d500      	bpl.n	80026bc <__trace_ready+0xc>
 80026ba:	4770      	bx	lr
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 80026bc:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
void __trace_ready(thread_t *tp, msg_t msg) {
 80026c0:	b410      	push	{r4}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 80026c2:	f8d3 408c 	ldr.w	r4, [r3, #140]	; 0x8c
 80026c6:	00d3      	lsls	r3, r2, #3
 80026c8:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->state       = (uint8_t)tp->state;
    oip->trace_buffer.ptr->u.rdy.tp    = tp;
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 80026cc:	e9c4 0102 	strd	r0, r1, [r4, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 80026d0:	7023      	strb	r3, [r4, #0]
    trace_next(oip);
  }
}
 80026d2:	bc10      	pop	{r4}
    trace_next(oip);
 80026d4:	f7ff bfcc 	b.w	8002670 <trace_next.constprop.0>
 80026d8:	240003f0 	.word	0x240003f0
 80026dc:	00000000 	.word	0x00000000

080026e0 <__trace_switch>:
 * @notapi
 */
void __trace_switch(thread_t *ntp, thread_t *otp) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80026e0:	4b0a      	ldr	r3, [pc, #40]	; (800270c <__trace_switch+0x2c>)
 80026e2:	f8b3 2088 	ldrh.w	r2, [r3, #136]	; 0x88
 80026e6:	0792      	lsls	r2, r2, #30
 80026e8:	d500      	bpl.n	80026ec <__trace_switch+0xc>
 80026ea:	4770      	bx	lr
void __trace_switch(thread_t *ntp, thread_t *otp) {
 80026ec:	b410      	push	{r4}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80026ee:	f891 2024 	ldrb.w	r2, [r1, #36]	; 0x24
 80026f2:	f8d3 408c 	ldr.w	r4, [r3, #140]	; 0x8c
 80026f6:	00d3      	lsls	r3, r2, #3
    oip->trace_buffer.ptr->state       = (uint8_t)otp->state;
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80026f8:	6a89      	ldr	r1, [r1, #40]	; 0x28
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80026fa:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80026fe:	e9c4 0102 	strd	r0, r1, [r4, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002702:	7023      	strb	r3, [r4, #0]
    trace_next(oip);
  }
}
 8002704:	bc10      	pop	{r4}
    trace_next(oip);
 8002706:	f7ff bfb3 	b.w	8002670 <trace_next.constprop.0>
 800270a:	bf00      	nop
 800270c:	240003f0 	.word	0x240003f0

08002710 <__trace_isr_enter>:
 * @notapi
 */
void __trace_isr_enter(const char *isr) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002710:	4a0a      	ldr	r2, [pc, #40]	; (800273c <__trace_isr_enter+0x2c>)
 8002712:	f8b2 3088 	ldrh.w	r3, [r2, #136]	; 0x88
void __trace_isr_enter(const char *isr) {
 8002716:	b510      	push	{r4, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002718:	f013 0404 	ands.w	r4, r3, #4
 800271c:	d000      	beq.n	8002720 <__trace_isr_enter+0x10>
    oip->trace_buffer.ptr->state       = 0U;
    oip->trace_buffer.ptr->u.isr.name  = isr;
    trace_next(oip);
    port_unlock_from_isr();
  }
}
 800271e:	bd10      	pop	{r4, pc}
 8002720:	2330      	movs	r3, #48	; 0x30
 8002722:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002726:	2103      	movs	r1, #3
 8002728:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 800272c:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800272e:	6098      	str	r0, [r3, #8]
    trace_next(oip);
 8002730:	f7ff ff9e 	bl	8002670 <trace_next.constprop.0>
 8002734:	f384 8811 	msr	BASEPRI, r4
}
 8002738:	bd10      	pop	{r4, pc}
 800273a:	bf00      	nop
 800273c:	240003f0 	.word	0x240003f0

08002740 <__trace_isr_leave>:
 * @notapi
 */
void __trace_isr_leave(const char *isr) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002740:	4a0a      	ldr	r2, [pc, #40]	; (800276c <__trace_isr_leave+0x2c>)
 8002742:	f8b2 3088 	ldrh.w	r3, [r2, #136]	; 0x88
void __trace_isr_leave(const char *isr) {
 8002746:	b510      	push	{r4, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002748:	f013 0404 	ands.w	r4, r3, #4
 800274c:	d000      	beq.n	8002750 <__trace_isr_leave+0x10>
    oip->trace_buffer.ptr->state       = 0U;
    oip->trace_buffer.ptr->u.isr.name  = isr;
    trace_next(oip);
    port_unlock_from_isr();
  }
}
 800274e:	bd10      	pop	{r4, pc}
 8002750:	2330      	movs	r3, #48	; 0x30
 8002752:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002756:	2104      	movs	r1, #4
 8002758:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 800275c:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800275e:	6098      	str	r0, [r3, #8]
    trace_next(oip);
 8002760:	f7ff ff86 	bl	8002670 <trace_next.constprop.0>
 8002764:	f384 8811 	msr	BASEPRI, r4
}
 8002768:	bd10      	pop	{r4, pc}
 800276a:	bf00      	nop
 800276c:	240003f0 	.word	0x240003f0

08002770 <vt_insert_first.constprop.0>:

/**
 * @brief   Inserts a timer as first element in a delta list.
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8002770:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002772:	4614      	mov	r4, r2
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8002774:	4d14      	ldr	r5, [pc, #80]	; (80027c8 <vt_insert_first.constprop.0+0x58>)
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8002776:	4603      	mov	r3, r0
 8002778:	460e      	mov	r6, r1
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
 800277a:	f105 0210 	add.w	r2, r5, #16
 800277e:	2c02      	cmp	r4, #2
  vtlp->lasttime = now;
 8002780:	61e9      	str	r1, [r5, #28]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002782:	f04f 0702 	mov.w	r7, #2
  dlp->delta      = delta;
 8002786:	6084      	str	r4, [r0, #8]
  dlp->prev       = dlhp;
 8002788:	bf38      	it	cc
 800278a:	2402      	movcc	r4, #2
 800278c:	6042      	str	r2, [r0, #4]
  dlp->next       = dlp->prev->next;
 800278e:	692a      	ldr	r2, [r5, #16]
 8002790:	6002      	str	r2, [r0, #0]
  dlp->next->prev = dlp;
 8002792:	6050      	str	r0, [r2, #4]
  stStartAlarm(time);
 8002794:	1908      	adds	r0, r1, r4
  dlhp->next      = dlp;
 8002796:	612b      	str	r3, [r5, #16]
 8002798:	f7fd feea 	bl	8000570 <stStartAlarm>
  return stGetCounter();
 800279c:	f7fd fee0 	bl	8000560 <stGetCounter>
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80027a0:	1b82      	subs	r2, r0, r6
 80027a2:	4603      	mov	r3, r0
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80027a4:	42a2      	cmp	r2, r4
 80027a6:	d207      	bcs.n	80027b8 <vt_insert_first.constprop.0+0x48>
    delay = currdelta;
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80027a8:	2f02      	cmp	r7, #2
 80027aa:	d800      	bhi.n	80027ae <vt_insert_first.constprop.0+0x3e>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80027ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 80027ae:	2001      	movs	r0, #1
}
 80027b0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 80027b4:	f7ff bf54 	b.w	8002660 <chRFCUCollectFaultsI>
    currdelta += (sysinterval_t)1;
 80027b8:	1c7c      	adds	r4, r7, #1
  stSetAlarm(time);
 80027ba:	1930      	adds	r0, r6, r4
 80027bc:	4627      	mov	r7, r4
    now = newnow;
 80027be:	461e      	mov	r6, r3
 80027c0:	f7fd fee6 	bl	8000590 <stSetAlarm>
  while (true) {
 80027c4:	e7ea      	b.n	800279c <vt_insert_first.constprop.0+0x2c>
 80027c6:	bf00      	nop
 80027c8:	240003f0 	.word	0x240003f0
 80027cc:	00000000 	.word	0x00000000

080027d0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 80027d0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80027d4:	4e3c      	ldr	r6, [pc, #240]	; (80028c8 <chVTDoTickI+0xf8>)
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 80027d6:	2700      	movs	r7, #0
 80027d8:	f04f 0930 	mov.w	r9, #48	; 0x30
 80027dc:	f106 0810 	add.w	r8, r6, #16
 80027e0:	e009      	b.n	80027f6 <chVTDoTickI+0x26>
 80027e2:	f387 8811 	msr	BASEPRI, r7
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 80027e6:	e9d4 3103 	ldrd	r3, r1, [r4, #12]
 80027ea:	4620      	mov	r0, r4
 80027ec:	4798      	blx	r3
 80027ee:	f389 8811 	msr	BASEPRI, r9

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 80027f2:	6963      	ldr	r3, [r4, #20]
 80027f4:	b9ab      	cbnz	r3, 8002822 <chVTDoTickI+0x52>
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 80027f6:	6934      	ldr	r4, [r6, #16]
  return stGetCounter();
 80027f8:	f7fd feb2 	bl	8000560 <stGetCounter>
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80027fc:	69f3      	ldr	r3, [r6, #28]
 80027fe:	4605      	mov	r5, r0
    if (nowdelta < vtp->dlist.delta) {
 8002800:	68a2      	ldr	r2, [r4, #8]
 8002802:	1ac1      	subs	r1, r0, r3
 8002804:	428a      	cmp	r2, r1
 8002806:	d82c      	bhi.n	8002862 <chVTDoTickI+0x92>
  return systime + (systime_t)interval;
 8002808:	189d      	adds	r5, r3, r2
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 800280a:	e9d4 1000 	ldrd	r1, r0, [r4]
    vtlp->lasttime = lasttime;
 800280e:	61f5      	str	r5, [r6, #28]
 8002810:	6001      	str	r1, [r0, #0]
  dlp->next->prev = dlp->prev;
 8002812:	6048      	str	r0, [r1, #4]
    vtp->dlist.next = NULL;
 8002814:	6027      	str	r7, [r4, #0]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002816:	6933      	ldr	r3, [r6, #16]
 8002818:	4543      	cmp	r3, r8
 800281a:	d1e2      	bne.n	80027e2 <chVTDoTickI+0x12>
  stStopAlarm();
 800281c:	f7fd feb0 	bl	8000580 <stStopAlarm>
}
 8002820:	e7df      	b.n	80027e2 <chVTDoTickI+0x12>
  return stGetCounter();
 8002822:	f7fd fe9d 	bl	8000560 <stGetCounter>
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8002826:	6963      	ldr	r3, [r4, #20]
  return (sysinterval_t)((systime_t)(end - start));
 8002828:	eba0 0b05 	sub.w	fp, r0, r5
 800282c:	4682      	mov	sl, r0
 800282e:	455b      	cmp	r3, fp
 8002830:	d32f      	bcc.n	8002892 <chVTDoTickI+0xc2>
  return (bool)(dlhp == dlhp->next);
 8002832:	6931      	ldr	r1, [r6, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8002834:	4541      	cmp	r1, r8
 8002836:	d03d      	beq.n	80028b4 <chVTDoTickI+0xe4>
  while (likely(dlp->delta < delta)) {
 8002838:	688a      	ldr	r2, [r1, #8]
 800283a:	4293      	cmp	r3, r2
 800283c:	d904      	bls.n	8002848 <chVTDoTickI+0x78>
    dlp = dlp->next;
 800283e:	6809      	ldr	r1, [r1, #0]
    delta -= dlp->delta;
 8002840:	1a9b      	subs	r3, r3, r2
  while (likely(dlp->delta < delta)) {
 8002842:	688a      	ldr	r2, [r1, #8]
 8002844:	429a      	cmp	r2, r3
 8002846:	d3fa      	bcc.n	800283e <chVTDoTickI+0x6e>
  dlp->prev       = dlp->next->prev;
 8002848:	684a      	ldr	r2, [r1, #4]
  dlp->delta      = delta;
 800284a:	60a3      	str	r3, [r4, #8]
  dlp->prev       = dlp->next->prev;
 800284c:	e9c4 1200 	strd	r1, r2, [r4]
  dlp->prev->next = dlp;
 8002850:	6014      	str	r4, [r2, #0]
  dlp->delta -= delta;
 8002852:	688a      	ldr	r2, [r1, #8]
  dlhp->prev      = dlp;
 8002854:	604c      	str	r4, [r1, #4]
  dlp->delta -= delta;
 8002856:	1ad2      	subs	r2, r2, r3
  dlhp->delta = (sysinterval_t)-1;
 8002858:	f04f 33ff 	mov.w	r3, #4294967295
  dlp->delta -= delta;
 800285c:	608a      	str	r2, [r1, #8]
  dlhp->delta = (sysinterval_t)-1;
 800285e:	61b3      	str	r3, [r6, #24]
}
 8002860:	e7c9      	b.n	80027f6 <chVTDoTickI+0x26>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002862:	6931      	ldr	r1, [r6, #16]
 8002864:	4541      	cmp	r1, r8
 8002866:	d012      	beq.n	800288e <chVTDoTickI+0xbe>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;
 8002868:	4413      	add	r3, r2
 800286a:	2702      	movs	r7, #2
  vtlp->lasttime += nowdelta;
 800286c:	61f0      	str	r0, [r6, #28]
  vtp->dlist.delta -= nowdelta;
 800286e:	1a1b      	subs	r3, r3, r0
 8002870:	42bb      	cmp	r3, r7
 8002872:	461e      	mov	r6, r3
 8002874:	60a3      	str	r3, [r4, #8]
 8002876:	bf38      	it	cc
 8002878:	463e      	movcc	r6, r7
  stSetAlarm(time);
 800287a:	19a8      	adds	r0, r5, r6
 800287c:	f7fd fe88 	bl	8000590 <stSetAlarm>
  return stGetCounter();
 8002880:	f7fd fe6e 	bl	8000560 <stGetCounter>
 8002884:	1b45      	subs	r5, r0, r5
    if (likely(nowdelta < delay)) {
 8002886:	42ae      	cmp	r6, r5
 8002888:	d910      	bls.n	80028ac <chVTDoTickI+0xdc>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 800288a:	2f02      	cmp	r7, #2
 800288c:	d809      	bhi.n	80028a2 <chVTDoTickI+0xd2>

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800288e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8002892:	2002      	movs	r0, #2
 8002894:	f7ff fee4 	bl	8002660 <chRFCUCollectFaultsI>
  return (bool)(dlhp == dlhp->next);
 8002898:	6931      	ldr	r1, [r6, #16]
      if (ch_dlist_isempty(&vtlp->dlist)) {
 800289a:	4541      	cmp	r1, r8
 800289c:	d012      	beq.n	80028c4 <chVTDoTickI+0xf4>
 800289e:	465b      	mov	r3, fp
 80028a0:	e7ca      	b.n	8002838 <chVTDoTickI+0x68>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 80028a2:	2001      	movs	r0, #1
}
 80028a4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 80028a8:	f7ff beda 	b.w	8002660 <chRFCUCollectFaultsI>
    currdelta += (sysinterval_t)1;
 80028ac:	3701      	adds	r7, #1
    now = newnow;
 80028ae:	4605      	mov	r5, r0
    currdelta += (sysinterval_t)1;
 80028b0:	463e      	mov	r6, r7
  while (true) {
 80028b2:	e7e2      	b.n	800287a <chVTDoTickI+0xaa>
        delay = vtp->reload - nowdelta;
 80028b4:	442b      	add	r3, r5
 80028b6:	1a1a      	subs	r2, r3, r0
        vt_insert_first(vtlp, vtp, now, delay);
 80028b8:	4651      	mov	r1, sl
 80028ba:	4620      	mov	r0, r4
}
 80028bc:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vt_insert_first(vtlp, vtp, now, delay);
 80028c0:	f7ff bf56 	b.w	8002770 <vt_insert_first.constprop.0>
        delay = (sysinterval_t)0;
 80028c4:	2200      	movs	r2, #0
 80028c6:	e7f7      	b.n	80028b8 <chVTDoTickI+0xe8>
 80028c8:	240003f0 	.word	0x240003f0
 80028cc:	00000000 	.word	0x00000000

080028d0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80028d0:	b510      	push	{r4, lr}
 80028d2:	4604      	mov	r4, r0
  __trace_ready(tp, tp->u.rdymsg);
 80028d4:	6a81      	ldr	r1, [r0, #40]	; 0x28
 80028d6:	f7ff feeb 	bl	80026b0 <__trace_ready>
  tp->state = CH_STATE_READY;
 80028da:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80028dc:	69a3      	ldr	r3, [r4, #24]
  } while (unlikely(pqp->prio >= p->prio));
 80028de:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 80028e0:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    pqp = pqp->next;
 80028e4:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80028e6:	689a      	ldr	r2, [r3, #8]
 80028e8:	428a      	cmp	r2, r1
 80028ea:	d2fb      	bcs.n	80028e4 <chSchReadyI+0x14>
  p->prev       = pqp->prev;
 80028ec:	685a      	ldr	r2, [r3, #4]
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
 80028ee:	4620      	mov	r0, r4
  p->next       = pqp;
 80028f0:	6023      	str	r3, [r4, #0]
  p->prev       = pqp->prev;
 80028f2:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 80028f4:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 80028f6:	605c      	str	r4, [r3, #4]
 80028f8:	bd10      	pop	{r4, pc}
 80028fa:	bf00      	nop
 80028fc:	0000      	movs	r0, r0
	...

08002900 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8002900:	b538      	push	{r3, r4, r5, lr}
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
 8002902:	4b0b      	ldr	r3, [pc, #44]	; (8002930 <chSchGoSleepS+0x30>)
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8002904:	2101      	movs	r1, #1
  ch_priority_queue_t *p = pqp->next;
 8002906:	681c      	ldr	r4, [r3, #0]
  thread_t *otp = __instance_get_currthread(oip);
 8002908:	68dd      	ldr	r5, [r3, #12]
  otp->state = newstate;
 800290a:	f885 0024 	strb.w	r0, [r5, #36]	; 0x24
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800290e:	4620      	mov	r0, r4
  pqp->next       = p->next;
 8002910:	6822      	ldr	r2, [r4, #0]
  pqp->next->prev = pqp;
 8002912:	6053      	str	r3, [r2, #4]
  pqp->next       = p->next;
 8002914:	601a      	str	r2, [r3, #0]
  ntp->state = CH_STATE_CURRENT;
 8002916:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
  chSysSwitch(ntp, otp);
 800291a:	4629      	mov	r1, r5
  __instance_set_currthread(oip, ntp);
 800291c:	60dc      	str	r4, [r3, #12]
  chSysSwitch(ntp, otp);
 800291e:	f7ff fedf 	bl	80026e0 <__trace_switch>
 8002922:	4629      	mov	r1, r5
 8002924:	4620      	mov	r0, r4
}
 8002926:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 800292a:	f7fd bd49 	b.w	80003c0 <__port_switch>
 800292e:	bf00      	nop
 8002930:	240003f0 	.word	0x240003f0
	...

08002940 <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8002940:	4b04      	ldr	r3, [pc, #16]	; (8002954 <chSchIsPreemptionRequired+0x14>)
 8002942:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8002944:	68db      	ldr	r3, [r3, #12]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8002946:	6890      	ldr	r0, [r2, #8]
 8002948:	689b      	ldr	r3, [r3, #8]
#endif
}
 800294a:	4298      	cmp	r0, r3
 800294c:	bf94      	ite	ls
 800294e:	2000      	movls	r0, #0
 8002950:	2001      	movhi	r0, #1
 8002952:	4770      	bx	lr
 8002954:	240003f0 	.word	0x240003f0
	...

08002960 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8002960:	b538      	push	{r3, r4, r5, lr}
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
 8002962:	4b13      	ldr	r3, [pc, #76]	; (80029b0 <chSchDoPreemption+0x50>)
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8002964:	2101      	movs	r1, #1
  ch_priority_queue_t *p = pqp->next;
 8002966:	681d      	ldr	r5, [r3, #0]
  thread_t *otp = __instance_get_currthread(oip);
 8002968:	68dc      	ldr	r4, [r3, #12]
  pqp->next       = p->next;
 800296a:	682a      	ldr	r2, [r5, #0]
  __trace_ready(tp, tp->u.rdymsg);
 800296c:	4620      	mov	r0, r4
  pqp->next->prev = pqp;
 800296e:	6053      	str	r3, [r2, #4]
  pqp->next       = p->next;
 8002970:	601a      	str	r2, [r3, #0]
  ntp->state = CH_STATE_CURRENT;
 8002972:	f885 1024 	strb.w	r1, [r5, #36]	; 0x24
  __trace_ready(tp, tp->u.rdymsg);
 8002976:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  __instance_set_currthread(oip, ntp);
 8002978:	60dd      	str	r5, [r3, #12]
  __trace_ready(tp, tp->u.rdymsg);
 800297a:	f7ff fe99 	bl	80026b0 <__trace_ready>
  tp->state = CH_STATE_READY;
 800297e:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8002980:	69a3      	ldr	r3, [r4, #24]
  } while (unlikely(pqp->prio > p->prio));
 8002982:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8002984:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    pqp = pqp->next;
 8002988:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 800298a:	689a      	ldr	r2, [r3, #8]
 800298c:	428a      	cmp	r2, r1
 800298e:	d8fb      	bhi.n	8002988 <chSchDoPreemption+0x28>
  p->prev       = pqp->prev;
 8002990:	685a      	ldr	r2, [r3, #4]
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8002992:	4621      	mov	r1, r4
  p->next       = pqp;
 8002994:	6023      	str	r3, [r4, #0]
 8002996:	4628      	mov	r0, r5
  p->prev       = pqp->prev;
 8002998:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 800299a:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 800299c:	605c      	str	r4, [r3, #4]
 800299e:	f7ff fe9f 	bl	80026e0 <__trace_switch>
 80029a2:	4621      	mov	r1, r4
 80029a4:	4628      	mov	r0, r5
}
 80029a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 80029aa:	f7fd bd09 	b.w	80003c0 <__port_switch>
 80029ae:	bf00      	nop
 80029b0:	240003f0 	.word	0x240003f0
	...

080029c0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80029c0:	b538      	push	{r3, r4, r5, lr}
 80029c2:	2330      	movs	r3, #48	; 0x30
 80029c4:	f383 8811 	msr	BASEPRI, r3
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 80029c8:	4b12      	ldr	r3, [pc, #72]	; (8002a14 <chThdExit+0x54>)
 80029ca:	68dc      	ldr	r4, [r3, #12]
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(currtp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80029cc:	f104 052c 	add.w	r5, r4, #44	; 0x2c
  return (bool)(lp->next != lp);
 80029d0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  currtp->u.exitcode = msg;
 80029d2:	62a0      	str	r0, [r4, #40]	; 0x28
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80029d4:	429d      	cmp	r5, r3
 80029d6:	d107      	bne.n	80029e8 <chThdExit+0x28>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 80029d8:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 80029dc:	b183      	cbz	r3, 8002a00 <chThdExit+0x40>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80029de:	200f      	movs	r0, #15
}
 80029e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 80029e4:	f7ff bf8c 	b.w	8002900 <chSchGoSleepS>
  lp->next = p->next;
 80029e8:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 80029ea:	4618      	mov	r0, r3
 80029ec:	62e2      	str	r2, [r4, #44]	; 0x2c
 80029ee:	f7ff ff6f 	bl	80028d0 <chSchReadyI>
  return (bool)(lp->next != lp);
 80029f2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80029f4:	42ab      	cmp	r3, r5
 80029f6:	d1f7      	bne.n	80029e8 <chThdExit+0x28>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 80029f8:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 80029fc:	2b00      	cmp	r3, #0
 80029fe:	d1ee      	bne.n	80029de <chThdExit+0x1e>
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8002a00:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8002a04:	079b      	lsls	r3, r3, #30
 8002a06:	d1ea      	bne.n	80029de <chThdExit+0x1e>
  p->prev->next = p->next;
 8002a08:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8002a0c:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002a0e:	605a      	str	r2, [r3, #4]
  return p;
 8002a10:	e7e5      	b.n	80029de <chThdExit+0x1e>
 8002a12:	bf00      	nop
 8002a14:	240003f0 	.word	0x240003f0
	...

08002a20 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8002a20:	4603      	mov	r3, r0

  if (*trp != NULL) {
 8002a22:	6800      	ldr	r0, [r0, #0]
 8002a24:	b120      	cbz	r0, 8002a30 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002a26:	2200      	movs	r2, #0
 8002a28:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8002a2a:	6281      	str	r1, [r0, #40]	; 0x28
    (void) chSchReadyI(tp);
 8002a2c:	f7ff bf50 	b.w	80028d0 <chSchReadyI>
  }
}
 8002a30:	4770      	bx	lr
 8002a32:	bf00      	nop
	...

08002a40 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002a40:	4603      	mov	r3, r0
  return (bool)(qp->next != qp);
 8002a42:	6800      	ldr	r0, [r0, #0]

  if (ch_queue_notempty(&tqp->queue)) {
 8002a44:	4283      	cmp	r3, r0
 8002a46:	d005      	beq.n	8002a54 <chThdDequeueNextI+0x14>
  qp->next       = p->next;
 8002a48:	6802      	ldr	r2, [r0, #0]
 8002a4a:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 8002a4c:	6053      	str	r3, [r2, #4]

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8002a4e:	6281      	str	r1, [r0, #40]	; 0x28
  (void) chSchReadyI(tp);
 8002a50:	f7ff bf3e 	b.w	80028d0 <chSchReadyI>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8002a54:	4770      	bx	lr
 8002a56:	bf00      	nop
	...

08002a60 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8002a62:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8002a64:	42a0      	cmp	r0, r4
 8002a66:	d021      	beq.n	8002aac <chEvtBroadcastFlagsI+0x4c>
 8002a68:	4607      	mov	r7, r0
 8002a6a:	460d      	mov	r5, r1
    tp->u.rdymsg = MSG_OK;
 8002a6c:	2600      	movs	r6, #0
 8002a6e:	e004      	b.n	8002a7a <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002a70:	2a0b      	cmp	r2, #11
 8002a72:	d01c      	beq.n	8002aae <chEvtBroadcastFlagsI+0x4e>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8002a74:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8002a76:	42a7      	cmp	r7, r4
 8002a78:	d018      	beq.n	8002aac <chEvtBroadcastFlagsI+0x4c>
    elp->flags |= flags;
 8002a7a:	68e3      	ldr	r3, [r4, #12]
 8002a7c:	432b      	orrs	r3, r5
 8002a7e:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8002a80:	b115      	cbz	r5, 8002a88 <chEvtBroadcastFlagsI+0x28>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8002a82:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8002a84:	421d      	tst	r5, r3
 8002a86:	d0f5      	beq.n	8002a74 <chEvtBroadcastFlagsI+0x14>
  tp->epending |= events;
 8002a88:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 8002a8c:	6b81      	ldr	r1, [r0, #56]	; 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a8e:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
  tp->epending |= events;
 8002a92:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a94:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 8002a96:	6383      	str	r3, [r0, #56]	; 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a98:	d1ea      	bne.n	8002a70 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002a9a:	6a82      	ldr	r2, [r0, #40]	; 0x28
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a9c:	4213      	tst	r3, r2
 8002a9e:	d0e9      	beq.n	8002a74 <chEvtBroadcastFlagsI+0x14>
    tp->u.rdymsg = MSG_OK;
 8002aa0:	6286      	str	r6, [r0, #40]	; 0x28
    (void) chSchReadyI(tp);
 8002aa2:	f7ff ff15 	bl	80028d0 <chSchReadyI>
    elp = elp->next;
 8002aa6:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8002aa8:	42a7      	cmp	r7, r4
 8002aaa:	d1e6      	bne.n	8002a7a <chEvtBroadcastFlagsI+0x1a>
  }
}
 8002aac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8002aae:	6a82      	ldr	r2, [r0, #40]	; 0x28
      ((tp->state == CH_STATE_WTANDEVT) &&
 8002ab0:	439a      	bics	r2, r3
 8002ab2:	d1df      	bne.n	8002a74 <chEvtBroadcastFlagsI+0x14>
 8002ab4:	e7f4      	b.n	8002aa0 <chEvtBroadcastFlagsI+0x40>
 8002ab6:	bf00      	nop
	...

08002ac0 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002ac0:	f3ef 8309 	mrs	r3, PSP
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8002ac4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002ac6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002aca:	2300      	movs	r3, #0
 8002acc:	f383 8811 	msr	BASEPRI, r3
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8002ad0:	4770      	bx	lr
 8002ad2:	bf00      	nop
	...

08002ae0 <__port_irq_epilogue>:
 8002ae0:	2330      	movs	r3, #48	; 0x30
 8002ae2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8002ae6:	4b0d      	ldr	r3, [pc, #52]	; (8002b1c <__port_irq_epilogue+0x3c>)
 8002ae8:	685b      	ldr	r3, [r3, #4]
 8002aea:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8002aee:	d102      	bne.n	8002af6 <__port_irq_epilogue+0x16>
 8002af0:	f383 8811 	msr	BASEPRI, r3
 8002af4:	4770      	bx	lr
void __port_irq_epilogue(void) {
 8002af6:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002af8:	f3ef 8409 	mrs	r4, PSP

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8002afc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
 8002b00:	3c20      	subs	r4, #32
    ectxp->xpsr = 0x01000000U;
 8002b02:	61e3      	str	r3, [r4, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002b04:	f384 8809 	msr	PSP, r4
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8002b08:	f7ff ff1a 	bl	8002940 <chSchIsPreemptionRequired>
 8002b0c:	b110      	cbz	r0, 8002b14 <__port_irq_epilogue+0x34>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8002b0e:	4b04      	ldr	r3, [pc, #16]	; (8002b20 <__port_irq_epilogue+0x40>)
 8002b10:	61a3      	str	r3, [r4, #24]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8002b12:	bd10      	pop	{r4, pc}
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8002b14:	4b03      	ldr	r3, [pc, #12]	; (8002b24 <__port_irq_epilogue+0x44>)
 8002b16:	61a3      	str	r3, [r4, #24]
}
 8002b18:	bd10      	pop	{r4, pc}
 8002b1a:	bf00      	nop
 8002b1c:	e000ed00 	.word	0xe000ed00
 8002b20:	080003e3 	.word	0x080003e3
 8002b24:	080003e6 	.word	0x080003e6
	...

08002b30 <main>:

/*
 * Application entry point.
 */
int main(void) {
}
 8002b30:	2000      	movs	r0, #0
 8002b32:	4770      	bx	lr

08002b34 <memset>:
 8002b34:	0783      	lsls	r3, r0, #30
 8002b36:	b530      	push	{r4, r5, lr}
 8002b38:	d048      	beq.n	8002bcc <memset+0x98>
 8002b3a:	1e54      	subs	r4, r2, #1
 8002b3c:	2a00      	cmp	r2, #0
 8002b3e:	d03f      	beq.n	8002bc0 <memset+0x8c>
 8002b40:	b2ca      	uxtb	r2, r1
 8002b42:	4603      	mov	r3, r0
 8002b44:	e001      	b.n	8002b4a <memset+0x16>
 8002b46:	3c01      	subs	r4, #1
 8002b48:	d33a      	bcc.n	8002bc0 <memset+0x8c>
 8002b4a:	f803 2b01 	strb.w	r2, [r3], #1
 8002b4e:	079d      	lsls	r5, r3, #30
 8002b50:	d1f9      	bne.n	8002b46 <memset+0x12>
 8002b52:	2c03      	cmp	r4, #3
 8002b54:	d92d      	bls.n	8002bb2 <memset+0x7e>
 8002b56:	b2cd      	uxtb	r5, r1
 8002b58:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8002b5c:	2c0f      	cmp	r4, #15
 8002b5e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8002b62:	d936      	bls.n	8002bd2 <memset+0x9e>
 8002b64:	f1a4 0210 	sub.w	r2, r4, #16
 8002b68:	f022 0c0f 	bic.w	ip, r2, #15
 8002b6c:	f103 0e20 	add.w	lr, r3, #32
 8002b70:	44e6      	add	lr, ip
 8002b72:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 8002b76:	f103 0210 	add.w	r2, r3, #16
 8002b7a:	e942 5504 	strd	r5, r5, [r2, #-16]
 8002b7e:	e942 5502 	strd	r5, r5, [r2, #-8]
 8002b82:	3210      	adds	r2, #16
 8002b84:	4572      	cmp	r2, lr
 8002b86:	d1f8      	bne.n	8002b7a <memset+0x46>
 8002b88:	f10c 0201 	add.w	r2, ip, #1
 8002b8c:	f014 0f0c 	tst.w	r4, #12
 8002b90:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 8002b94:	f004 0c0f 	and.w	ip, r4, #15
 8002b98:	d013      	beq.n	8002bc2 <memset+0x8e>
 8002b9a:	f1ac 0304 	sub.w	r3, ip, #4
 8002b9e:	f023 0303 	bic.w	r3, r3, #3
 8002ba2:	3304      	adds	r3, #4
 8002ba4:	4413      	add	r3, r2
 8002ba6:	f842 5b04 	str.w	r5, [r2], #4
 8002baa:	4293      	cmp	r3, r2
 8002bac:	d1fb      	bne.n	8002ba6 <memset+0x72>
 8002bae:	f00c 0403 	and.w	r4, ip, #3
 8002bb2:	b12c      	cbz	r4, 8002bc0 <memset+0x8c>
 8002bb4:	b2c9      	uxtb	r1, r1
 8002bb6:	441c      	add	r4, r3
 8002bb8:	f803 1b01 	strb.w	r1, [r3], #1
 8002bbc:	429c      	cmp	r4, r3
 8002bbe:	d1fb      	bne.n	8002bb8 <memset+0x84>
 8002bc0:	bd30      	pop	{r4, r5, pc}
 8002bc2:	4664      	mov	r4, ip
 8002bc4:	4613      	mov	r3, r2
 8002bc6:	2c00      	cmp	r4, #0
 8002bc8:	d1f4      	bne.n	8002bb4 <memset+0x80>
 8002bca:	e7f9      	b.n	8002bc0 <memset+0x8c>
 8002bcc:	4603      	mov	r3, r0
 8002bce:	4614      	mov	r4, r2
 8002bd0:	e7bf      	b.n	8002b52 <memset+0x1e>
 8002bd2:	461a      	mov	r2, r3
 8002bd4:	46a4      	mov	ip, r4
 8002bd6:	e7e0      	b.n	8002b9a <memset+0x66>
